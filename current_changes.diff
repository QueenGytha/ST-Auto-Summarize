diff --git a/connectionProfiles.js b/connectionProfiles.js
index fc12b89..ba5eb48 100644
--- a/connectionProfiles.js
+++ b/connectionProfiles.js
@@ -1,121 +1,127 @@
-import { get_settings, set_settings, error, debug, toast_debounced, getContext } from './index.js';
-
-// Connection profiles
-let connection_profiles_active;
-function check_connection_profiles_active() {
-    // detect whether the connection profiles extension is active by checking for the UI elements
-    if (connection_profiles_active === undefined) {
-        connection_profiles_active = $('#sys-settings-button').find('#connection_profiles').length > 0
-    }
-    return connection_profiles_active;
-}
-async function get_current_connection_profile() {
-    if (!check_connection_profiles_active()) return;  // if the extension isn't active, return
-    // get the current connection profile
-    let ctx = getContext();
-    let result = await ctx.executeSlashCommandsWithOptions(`/profile`)
-    return result.pipe
-}
-async function get_connection_profile_api(name) {
-    // Get the API for the given connection profile name. If not given, get the current summary profile.
-    if (!check_connection_profiles_active()) return;  // if the extension isn't active, return
-    if (name === undefined) name = await get_summary_connection_profile()
-    let ctx = getContext();
-    let result = await ctx.executeSlashCommandsWithOptions(`/profile-get ${name}`)
-
-    if (!result.pipe) {
-        debug(`/profile-get ${name} returned nothing - no connection profile selected`)
-        return
-    }
-
-    let data;
-    try {
-        data = JSON.parse(result.pipe)
-    } catch {
-        error(`Failed to parse JSON from /profile-get for \"${name}\". Result:`)
-        error(result)
-        return
-    }
-
-    // If the API type isn't defined, it might be excluded from the connection profile. Assume based on mode.
-    if (data.api === undefined) {
-        debug(`API not defined in connection profile ${name}. Mode is ${data.mode}`)
-        if (data.mode === 'tc') return 'textgenerationwebui'
-        if (data.mode === 'cc') return 'openai'
-    }
-
-    // need to map the API type to a completion API
-    if (CONNECT_API_MAP[data.api] === undefined) {
-        error(`API type "${data.api}" not found in CONNECT_API_MAP - could not identify API.`)
-        return
-    }
-    return CONNECT_API_MAP[data.api].selected
-}
-async function get_summary_connection_profile() {
-    // get the current connection profile OR the default if it isn't valid for the current API
-    let name = get_settings('connection_profile');
-
-    // If none selected, invalid, or connection profiles not active, use the current profile
-    if (name === "" || !await verify_connection_profile(name) || !check_connection_profiles_active()) {
-        name = await get_current_connection_profile();
-    }
-
-    return name
-}
-async function set_connection_profile(name) {
-    // Set the connection profile
-    if (!check_connection_profiles_active()) return;  // if the extension isn't active, return
-    if (name === await get_current_connection_profile()) return;  // If already using the current preset, return
-    if (!await check_connection_profile_valid()) return;  // don't set an invalid preset
-
-    // Set the completion preset
-    debug(`Setting connection profile to "${name}"`)
-    if (get_settings('debug_mode')) {
-        toastr.info(`Setting connection profile to "${name}"`);
-    }
-    let ctx = getContext();
-    await ctx.executeSlashCommandsWithOptions(`/profile ${name}`)
-}
-async function get_connection_profiles() {
-    // Get a list of available connection profiles
-
-    if (!check_connection_profiles_active()) return;  // if the extension isn't active, return
-    let ctx = getContext();
-    let result = await ctx.executeSlashCommandsWithOptions(`/profile-list`)
-    try {
-        return JSON.parse(result.pipe)
-    } catch {
-        error("Failed to parse JSON from /profile-list. Result:")
-        error(result)
-    }
-
-}
-async function verify_connection_profile(name) {
-    // check if the given connection profile name is valid
-    if (!check_connection_profiles_active()) return;  // if the extension isn't active, return
-    if (name === "") return true;  // no profile selected, always valid
-
-    let names = await get_connection_profiles()
-    return names.includes(name)
-}
-async function check_connection_profile_valid()  {
-    // check whether the current connection profile selected for summarization is valid
-    if (!check_connection_profiles_active()) return;  // if the extension isn't active, return
-    let summary_connection = get_settings('connection_profile')
-    let valid = await verify_connection_profile(summary_connection)
-    if (!valid) {
-        toast_debounced(`Your selected summary connection profile "${summary_connection}" is not valid.`, "warning")
-    }
-    return valid
-}
-
-export {
-    check_connection_profiles_active,
-    get_current_connection_profile,
-    get_connection_profile_api,
-    get_summary_connection_profile,
-    set_connection_profile,
-    get_connection_profiles,
-    verify_connection_profile,
-    check_connection_profile_valid
+import { get_settings, set_settings, error, debug, toast_debounced, getContext } from './index.js';
+
+// Connection profiles
+let connection_profiles_active;
+function check_connection_profiles_active() {
+    // detect whether the connection profiles extension is active by checking for the UI elements
+    if (connection_profiles_active === undefined) {
+        connection_profiles_active = $('#sys-settings-button').find('#connection_profiles').length > 0
+    }
+    return connection_profiles_active;
+}
+async function get_current_connection_profile() {
+    if (!check_connection_profiles_active()) return;  // if the extension isn't active, return
+    // get the current connection profile
+    let ctx = getContext();
+    let result = await ctx.executeSlashCommandsWithOptions(`/profile`)
+    return result.pipe
+}
+async function get_connection_profile_api(name) {
+    // Get the API for the given connection profile name. If not given, get the current summary profile.
+    if (!check_connection_profiles_active()) return;  // if the extension isn't active, return
+    if (name === undefined) name = await get_summary_connection_profile()
+    let ctx = getContext();
+    let result = await ctx.executeSlashCommandsWithOptions(`/profile-get ${name}`)
+
+    if (!result.pipe) {
+        debug(`/profile-get ${name} returned nothing - no connection profile selected`)
+        return
+    }
+
+    let data;
+    try {
+        data = JSON.parse(result.pipe)
+    } catch {
+        error(`Failed to parse JSON from /profile-get for \"${name}\". Result:`)
+        error(result)
+        return
+    }
+
+    // If the API type isn't defined, it might be excluded from the connection profile. Assume based on mode.
+    if (data.api === undefined) {
+        debug(`API not defined in connection profile ${name}. Mode is ${data.mode}`)
+        if (data.mode === 'tc') return 'textgenerationwebui'
+        if (data.mode === 'cc') return 'openai'
+    }
+
+    // need to map the API type to a completion API
+    if (CONNECT_API_MAP[data.api] === undefined) {
+        error(`API type "${data.api}" not found in CONNECT_API_MAP - could not identify API.`)
+        return
+    }
+    return CONNECT_API_MAP[data.api].selected
+}
+async function get_summary_connection_profile() {
+    // get the current connection profile OR the default if it isn't valid for the current API
+    let name = get_settings('connection_profile');
+
+    // If none selected, invalid, or connection profiles not active, use the current profile
+    if (name === "" || !await verify_connection_profile(name) || !check_connection_profiles_active()) {
+        name = await get_current_connection_profile();
+    }
+
+    return name
+}
+async function set_connection_profile(name) {
+    // Set the connection profile
+    if (!check_connection_profiles_active()) return;  // if the extension isn't active, return
+    if (name === await get_current_connection_profile()) return;  // If already using the current preset, return
+    if (!await check_connection_profile_valid()) return;  // don't set an invalid preset
+
+    // Set the completion preset
+    debug(`Setting connection profile to "${name}"`)
+    if (get_settings('debug_mode')) {
+        toastr.info(`Setting connection profile to "${name}"`);
+    }
+    let ctx = getContext();
+    await ctx.executeSlashCommandsWithOptions(`/profile ${name}`)
+}
+async function get_connection_profiles() {
+    // Get a list of available connection profiles
+
+    if (!check_connection_profiles_active()) return;  // if the extension isn't active, return
+    let ctx = getContext();
+    let result = await ctx.executeSlashCommandsWithOptions(`/profile-list`)
+    try {
+        return JSON.parse(result.pipe)
+    } catch {
+        error("Failed to parse JSON from /profile-list. Result:")
+        error(result)
+    }
+
+}
+async function verify_connection_profile(name) {
+    // check if the given connection profile name is valid
+    if (!check_connection_profiles_active()) return;  // if the extension isn't active, return
+    if (name === "") return true;  // no profile selected, always valid
+
+    let names = await get_connection_profiles()
+    return names.includes(name)
+}
+async function check_connection_profile_valid()  {
+    // check whether the current connection profile selected for summarization is valid
+    if (!check_connection_profiles_active()) return;  // if the extension isn't active, return
+    let summary_connection = get_settings('connection_profile')
+    let valid = await verify_connection_profile(summary_connection)
+    if (!valid) {
+        toast_debounced(`Your selected summary connection profile "${summary_connection}" is not valid.`, "warning")
+    }
+    return valid
+}
+
+function reset_connection_profiles_cache() {
+    // Reset the cached value to force a re-check
+    connection_profiles_active = undefined;
+}
+
+export {
+    check_connection_profiles_active,
+    get_current_connection_profile,
+    get_connection_profile_api,
+    get_summary_connection_profile,
+    set_connection_profile,
+    get_connection_profiles,
+    verify_connection_profile,
+    check_connection_profile_valid,
+    reset_connection_profiles_cache
 };
\ No newline at end of file
diff --git a/eventHandlers.js b/eventHandlers.js
index 513d868..e1e316b 100644
--- a/eventHandlers.js
+++ b/eventHandlers.js
@@ -1,262 +1,265 @@
-import {
-    debug,
-    getContext,
-    chat_enabled,
-    get_settings,
-    refresh_memory,
-    auto_load_profile,
-    scrollChatToBottom,
-    auto_summarize_chat,
-    summarize_messages,
-    check_message_exclusion,
-    get_previous_swipe_memory,
-    clear_memory,
-    get_data,
-    set_data,
-    last_long_injection,
-    last_short_injection,
-    last_combined_injection,
-    last_scene_injection,
-    load_settings_html,
-    initialize_settings_listeners,
-    initialize_popout,
-    initialize_message_buttons,
-    initialize_group_member_buttons,
-    initialize_slash_commands,
-    initialize_menu_buttons,
-    addSceneBreakButton,
-    bindSceneBreakButton,
-    get_message_div,
-    saveChatDebounced,
-    set_character_enabled_button_states,
-    renderAllSceneBreaks,
-    generate_combined_summary,
-    get_manifest,
-    log,
-    refresh_settings,
-    update_connection_profile_dropdown,
-    check_st_version,
-    initialize_settings,
-    get_short_memory,
-    get_long_memory,
-    combined_memory_macro,
-    MacrosParser,
-    MemoryEditInterface,
-    short_memory_macro,
-    long_memory_macro,
-    streamingProcessor,
-    initializeSceneNavigatorBar,
-    renderSceneNavigatorBar,
-    load_combined_summary,
-    get_scene_memory_injection
-} from './index.js';
-
-// Event handling
-var last_message_swiped = null  // if an index, that was the last message swiped
-async function on_chat_event(event=null, data=null) {
-    debug(`[on_chat_event] event: ${event}, data: ${JSON.stringify(data)}`);
-    // When the chat is updated, check if the summarization should be triggered
-    debug("Chat updated: " + event)
-
-    const context = getContext();
-    let index = data
-
-    switch (event) {
-        case 'chat_changed':  // chat was changed
-            last_message_swiped = null;
-            auto_load_profile();  // load the profile for the current chat or character
-            refresh_memory();  // refresh the memory state
-            if (context?.chat?.length) {
-                scrollChatToBottom();  // scroll to the bottom of the chat (area is added due to memories)
-            }
-            break;
-
-        case 'message_deleted':   // message was deleted
-            last_message_swiped = null;
-            if (!chat_enabled()) break;  // if chat is disabled, do nothing
-            debug("Message deleted, refreshing memory")
-            refresh_memory();
-            break;
-
-        case 'before_message':
-            if (!chat_enabled()) break;  // if chat is disabled, do nothing
-            break;
-
-        // currently no triggers on user message rendered
-        case 'user_message':
-            last_message_swiped = null;
-            if (!chat_enabled()) break;  // if chat is disabled, do nothing
-            if (!get_settings('auto_summarize')) break;  // if auto-summarize is disabled, do nothing
-
-            // Summarize the chat if "include_user_messages" is enabled
-            if (get_settings('include_user_messages')) {
-                debug("New user message detected, summarizing")
-                await auto_summarize_chat();  // auto-summarize the chat (checks for exclusion criteria and whatnot)
-            }
-
-            break;
-
-        case 'char_message':
-            if (!chat_enabled()) break;  // if chat is disabled, do nothing
-            if (!context.groupId && context.characterId === undefined) break; // no characters or group selected
-            if (streamingProcessor && !streamingProcessor.isFinished) break;  // Streaming in-progress
-            if (last_message_swiped === index) {  // this is a swipe
-                let message = context.chat[index];
-                if (!get_settings('auto_summarize_on_swipe')) break;  // if auto-summarize on swipe is disabled, do nothing
-                if (!check_message_exclusion(message)) break;  // if the message is excluded, skip
-                if (!get_previous_swipe_memory(message, 'memory')) break;  // if the previous swipe doesn't have a memory, skip
-                debug("re-summarizing on swipe")
-                await summarize_messages(index);  // summarize the swiped message
-                refresh_memory()
-                break;
-            } else { // not a swipe
-                last_message_swiped = null;
-                if (!get_settings('auto_summarize')) break;  // if auto-summarize is disabled, do nothing
-                if (get_settings("auto_summarize_on_send")) break;  // if auto_summarize_on_send is enabled, don't auto-summarize on character message
-                debug("New message detected, summarizing")
-                await auto_summarize_chat();  // auto-summarize the chat (checks for exclusion criteria and whatnot)
-                break;
-            }
-
-        case 'message_edited':  // Message has been edited
-            last_message_swiped = null;
-            if (!chat_enabled()) break;  // if chat is disabled, do nothing
-            if (!get_settings('auto_summarize_on_edit')) break;  // if auto-summarize on edit is disabled, skip
-            if (!check_message_exclusion(context.chat[index])) break;  // if the message is excluded, skip
-            if (!get_data(context.chat[index], 'memory')) break;  // if the message doesn't have a memory, skip
-            debug("Message with memory edited, summarizing")
-            summarize_messages(index);  // summarize that message (no await so the message edit goes through)
-
-            // TODO: I'd like to be able to refresh the memory here, but we can't await the summarization because
-            //  then the message edit textbox doesn't close until the summary is done.
-
-            break;
-
-        case 'message_swiped':  // when this event occurs, don't summarize yet (a new_message event will follow)
-            if (!chat_enabled()) break;  // if chat is disabled, do nothing
-            debug("Message swiped, reloading memory")
-
-            // if this is creating a new swipe, remove the current memory.
-            // This is detected when the swipe ID is greater than the last index in the swipes array,
-            //  i.e. when the swipe ID is EQUAL to the length of the swipes array, not when it's length-1.
-            let message = context.chat[index];
-            if (message.swipe_id === message.swipes.length) {
-                clear_memory(message)
-            }
-
-            refresh_memory()
-            last_message_swiped = index;
-
-            // make sure the chat is scrolled to the bottom because the memory will change
-            scrollChatToBottom();
-            break;
-
-        case 'message_sent':
-            if (!chat_enabled()) break;
-            if (get_settings('debug_mode')) {
-                if (
-                    last_long_injection ||
-                    last_short_injection ||
-                    last_combined_injection ||
-                    last_scene_injection
-                ) {
-                    if (last_long_injection) debug(`[MEMORY INJECTION] long_injection:\n${last_long_injection}`);
-                    if (last_short_injection) debug(`[MEMORY INJECTION] short_injection:\n${last_short_injection}`);
-                    if (last_combined_injection) debug(`[MEMORY INJECTION] combined_injection:\n${last_combined_injection}`);
-                    if (last_scene_injection) debug(`[MEMORY INJECTION] scene_injection:\n${last_scene_injection}`);
-                }
-            }
-            break;
-
-        default:
-            if (!chat_enabled()) break;  // if chat is disabled, do nothing
-            debug(`Unknown event: "${event}", refreshing memory`)
-            refresh_memory();
-    }
-}
-
-// Entry point
-let memoryEditInterface;
-jQuery(async function () {
-    log(`Loading extension...`)
-
-    // Read version from manifest.json
-    const manifest = await get_manifest();
-    const VERSION = manifest.version;
-    log(`Version: ${VERSION}`)
-
-    check_st_version()
-
-    // Load settings
-    initialize_settings();
-
-    memoryEditInterface = new MemoryEditInterface()
-
-    // load settings html
-    await load_settings_html();
-
-    // initialize UI stuff
-    initialize_settings_listeners();
-    initialize_popout()
-    initialize_message_buttons();
-    initialize_group_member_buttons();
-    initialize_slash_commands();
-    initialize_menu_buttons();
-
-    addSceneBreakButton();
-    bindSceneBreakButton(get_message_div, getContext, set_data, get_data, saveChatDebounced);
-
-    // ST event listeners
-    let ctx = getContext();
-    let eventSource = ctx.eventSource;
-    let event_types = ctx.event_types;
-    debug(`[eventHandlers] Registered event_types: ${JSON.stringify(event_types)}`);
-    eventSource.on(event_types.CHAT_COMPLETION_PROMPT_READY, (id, stuff) => {
-        on_chat_event('chat_completion_prompt_ready', id);
-    });
-    eventSource.makeLast(event_types.CHARACTER_MESSAGE_RENDERED, (id) => on_chat_event('char_message', id));
-    eventSource.on(event_types.USER_MESSAGE_RENDERED, (id) => on_chat_event('user_message', id));
-    eventSource.on(event_types.GENERATE_BEFORE_COMBINE_PROMPTS, (id, stuff) => on_chat_event('before_message', id));
-    eventSource.on(event_types.MESSAGE_DELETED, (id) => on_chat_event('message_deleted', id));
-    eventSource.on(event_types.MESSAGE_EDITED, (id) => on_chat_event('message_edited', id));
-    eventSource.on(event_types.MESSAGE_SWIPED, (id) => on_chat_event('message_swiped', id));
-    eventSource.on(event_types.CHAT_CHANGED, () => on_chat_event('chat_changed'));
-    eventSource.on(event_types.MORE_MESSAGES_LOADED, refresh_memory)
-    eventSource.on(event_types.MESSAGE_SENT, (id) => on_chat_event('message_sent', id));
-    eventSource.on(event_types.MORE_MESSAGES_LOADED, () => {
-    refresh_memory();
-    renderAllSceneBreaks(get_message_div, getContext, get_data, set_data, saveChatDebounced);
-    renderSceneNavigatorBar();
-    });
-    eventSource.on(event_types.CHAT_CHANGED, () => {
-        renderAllSceneBreaks(get_message_div, getContext, get_data, set_data, saveChatDebounced);
-    });
-    eventSource.on('groupSelected', set_character_enabled_button_states)
-    eventSource.on(event_types.GROUP_UPDATED, set_character_enabled_button_states)
-
-    // Log all events for debugging
-Object.entries(event_types).forEach(([key, type]) => {
-    eventSource.on(type, (...args) => {
-        debug(`[eventHandlers] Event triggered: ${key} (${type}), args: ${JSON.stringify(args)}`);
-    });
-});
-
-    // Global Macros
-    MacrosParser.registerMacro(short_memory_macro, () => get_short_memory());
-    MacrosParser.registerMacro(long_memory_macro, () => get_long_memory());
-    MacrosParser.registerMacro(combined_memory_macro, () => load_combined_summary());
-
-    // Export to the Global namespace so can be used in the console for debugging
-    window.getContext = getContext;
-    window.refresh_memory = refresh_memory;
-    window.generate_combined_summary = generate_combined_summary;
-    window.refresh_settings = refresh_settings;
-    window.update_connection_profile_dropdown = update_connection_profile_dropdown;
-
-    initializeSceneNavigatorBar();
-});
-
-export {
-    on_chat_event,
-    memoryEditInterface
+import {
+    debug,
+    getContext,
+    chat_enabled,
+    get_settings,
+    refresh_memory,
+    auto_load_profile,
+    scrollChatToBottom,
+    auto_summarize_chat,
+    summarize_messages,
+    check_message_exclusion,
+    get_previous_swipe_memory,
+    clear_memory,
+    get_data,
+    set_data,
+    last_long_injection,
+    last_short_injection,
+    last_combined_injection,
+    last_scene_injection,
+    load_settings_html,
+    initialize_settings_listeners,
+    initialize_popout,
+    initialize_message_buttons,
+    initialize_group_member_buttons,
+    initialize_slash_commands,
+    initialize_menu_buttons,
+    addSceneBreakButton,
+    bindSceneBreakButton,
+    get_message_div,
+    saveChatDebounced,
+    set_character_enabled_button_states,
+    renderAllSceneBreaks,
+    generate_combined_summary,
+    get_manifest,
+    log,
+    refresh_settings,
+    update_connection_profile_dropdown,
+    check_st_version,
+    initialize_settings,
+    get_short_memory,
+    get_long_memory,
+    combined_memory_macro,
+    MacrosParser,
+    MemoryEditInterface,
+    short_memory_macro,
+    long_memory_macro,
+    streamingProcessor,
+    initializeSceneNavigatorBar,
+    renderSceneNavigatorBar,
+    load_combined_summary,
+    get_scene_memory_injection
+} from './index.js';
+
+// Event handling
+var last_message_swiped = null  // if an index, that was the last message swiped
+async function on_chat_event(event=null, data=null) {
+    debug(`[on_chat_event] event: ${event}, data: ${JSON.stringify(data)}`);
+    // When the chat is updated, check if the summarization should be triggered
+    debug("Chat updated: " + event)
+
+    const context = getContext();
+    let index = data
+
+    switch (event) {
+        case 'chat_changed':  // chat was changed
+            last_message_swiped = null;
+            auto_load_profile();  // load the profile for the current chat or character
+            refresh_memory();  // refresh the memory state
+            if (context?.chat?.length) {
+                scrollChatToBottom();  // scroll to the bottom of the chat (area is added due to memories)
+            }
+            break;
+
+        case 'message_deleted':   // message was deleted
+            last_message_swiped = null;
+            if (!chat_enabled()) break;  // if chat is disabled, do nothing
+            debug("Message deleted, refreshing memory")
+            refresh_memory();
+            break;
+
+        case 'before_message':
+            if (!chat_enabled()) break;  // if chat is disabled, do nothing
+            break;
+
+        // currently no triggers on user message rendered
+        case 'user_message':
+            last_message_swiped = null;
+            if (!chat_enabled()) break;  // if chat is disabled, do nothing
+            if (!get_settings('auto_summarize')) break;  // if auto-summarize is disabled, do nothing
+
+            // Summarize the chat if "include_user_messages" is enabled
+            if (get_settings('include_user_messages')) {
+                debug("New user message detected, summarizing")
+                await auto_summarize_chat();  // auto-summarize the chat (checks for exclusion criteria and whatnot)
+            }
+
+            break;
+
+        case 'char_message':
+            if (!chat_enabled()) break;  // if chat is disabled, do nothing
+            if (!context.groupId && context.characterId === undefined) break; // no characters or group selected
+            if (streamingProcessor && !streamingProcessor.isFinished) break;  // Streaming in-progress
+            if (last_message_swiped === index) {  // this is a swipe
+                let message = context.chat[index];
+                if (!get_settings('auto_summarize_on_swipe')) break;  // if auto-summarize on swipe is disabled, do nothing
+                if (!check_message_exclusion(message)) break;  // if the message is excluded, skip
+                if (!get_previous_swipe_memory(message, 'memory')) break;  // if the previous swipe doesn't have a memory, skip
+                debug("re-summarizing on swipe")
+                await summarize_messages(index);  // summarize the swiped message
+                refresh_memory()
+                break;
+            } else { // not a swipe
+                last_message_swiped = null;
+                if (!get_settings('auto_summarize')) break;  // if auto-summarize is disabled, do nothing
+                if (get_settings("auto_summarize_on_send")) break;  // if auto_summarize_on_send is enabled, don't auto-summarize on character message
+                debug("New message detected, summarizing")
+                await auto_summarize_chat();  // auto-summarize the chat (checks for exclusion criteria and whatnot)
+                break;
+            }
+
+        case 'message_edited':  // Message has been edited
+            last_message_swiped = null;
+            if (!chat_enabled()) break;  // if chat is disabled, do nothing
+            if (!get_settings('auto_summarize_on_edit')) break;  // if auto-summarize on edit is disabled, skip
+            if (!check_message_exclusion(context.chat[index])) break;  // if the message is excluded, skip
+            if (!get_data(context.chat[index], 'memory')) break;  // if the message doesn't have a memory, skip
+            debug("Message with memory edited, summarizing")
+            summarize_messages(index);  // summarize that message (no await so the message edit goes through)
+
+            // TODO: I'd like to be able to refresh the memory here, but we can't await the summarization because
+            //  then the message edit textbox doesn't close until the summary is done.
+
+            break;
+
+        case 'message_swiped':  // when this event occurs, don't summarize yet (a new_message event will follow)
+            if (!chat_enabled()) break;  // if chat is disabled, do nothing
+            debug("Message swiped, reloading memory")
+
+            // if this is creating a new swipe, remove the current memory.
+            // This is detected when the swipe ID is greater than the last index in the swipes array,
+            //  i.e. when the swipe ID is EQUAL to the length of the swipes array, not when it's length-1.
+            let message = context.chat[index];
+            if (message.swipe_id === message.swipes.length) {
+                clear_memory(message)
+            }
+
+            refresh_memory()
+            last_message_swiped = index;
+
+            // make sure the chat is scrolled to the bottom because the memory will change
+            scrollChatToBottom();
+            break;
+
+        case 'message_sent':
+            if (!chat_enabled()) break;
+            if (get_settings('debug_mode')) {
+                if (
+                    last_long_injection ||
+                    last_short_injection ||
+                    last_combined_injection ||
+                    last_scene_injection
+                ) {
+                    if (last_long_injection) debug(`[MEMORY INJECTION] long_injection:\n${last_long_injection}`);
+                    if (last_short_injection) debug(`[MEMORY INJECTION] short_injection:\n${last_short_injection}`);
+                    if (last_combined_injection) debug(`[MEMORY INJECTION] combined_injection:\n${last_combined_injection}`);
+                    if (last_scene_injection) debug(`[MEMORY INJECTION] scene_injection:\n${last_scene_injection}`);
+                }
+            }
+            break;
+
+        default:
+            if (!chat_enabled()) break;  // if chat is disabled, do nothing
+            debug(`Unknown event: "${event}", refreshing memory`)
+            refresh_memory();
+    }
+}
+
+// Entry point
+let memoryEditInterface;
+jQuery(async function () {
+    log(`Loading extension...`)
+
+    // Read version from manifest.json
+    const manifest = await get_manifest();
+    const VERSION = manifest.version;
+    log(`Version: ${VERSION}`)
+
+    check_st_version()
+
+    // Load settings
+    initialize_settings();
+
+    memoryEditInterface = new MemoryEditInterface()
+
+    // load settings html
+    await load_settings_html();
+
+    // initialize UI stuff
+    initialize_settings_listeners();
+    initialize_popout()
+    initialize_message_buttons();
+    initialize_group_member_buttons();
+    initialize_slash_commands();
+    initialize_menu_buttons();
+    
+    // Refresh settings UI to populate dropdowns and other elements
+    refresh_settings();
+
+    addSceneBreakButton();
+    bindSceneBreakButton(get_message_div, getContext, set_data, get_data, saveChatDebounced);
+
+    // ST event listeners
+    let ctx = getContext();
+    let eventSource = ctx.eventSource;
+    let event_types = ctx.event_types;
+    debug(`[eventHandlers] Registered event_types: ${JSON.stringify(event_types)}`);
+    eventSource.on(event_types.CHAT_COMPLETION_PROMPT_READY, (id, stuff) => {
+        on_chat_event('chat_completion_prompt_ready', id);
+    });
+    eventSource.makeLast(event_types.CHARACTER_MESSAGE_RENDERED, (id) => on_chat_event('char_message', id));
+    eventSource.on(event_types.USER_MESSAGE_RENDERED, (id) => on_chat_event('user_message', id));
+    eventSource.on(event_types.GENERATE_BEFORE_COMBINE_PROMPTS, (id, stuff) => on_chat_event('before_message', id));
+    eventSource.on(event_types.MESSAGE_DELETED, (id) => on_chat_event('message_deleted', id));
+    eventSource.on(event_types.MESSAGE_EDITED, (id) => on_chat_event('message_edited', id));
+    eventSource.on(event_types.MESSAGE_SWIPED, (id) => on_chat_event('message_swiped', id));
+    eventSource.on(event_types.CHAT_CHANGED, () => on_chat_event('chat_changed'));
+    eventSource.on(event_types.MORE_MESSAGES_LOADED, refresh_memory)
+    eventSource.on(event_types.MESSAGE_SENT, (id) => on_chat_event('message_sent', id));
+    eventSource.on(event_types.MORE_MESSAGES_LOADED, () => {
+    refresh_memory();
+    renderAllSceneBreaks(get_message_div, getContext, get_data, set_data, saveChatDebounced);
+    renderSceneNavigatorBar();
+    });
+    eventSource.on(event_types.CHAT_CHANGED, () => {
+        renderAllSceneBreaks(get_message_div, getContext, get_data, set_data, saveChatDebounced);
+    });
+    eventSource.on('groupSelected', set_character_enabled_button_states)
+    eventSource.on(event_types.GROUP_UPDATED, set_character_enabled_button_states)
+
+    // Log all events for debugging
+Object.entries(event_types).forEach(([key, type]) => {
+    eventSource.on(type, (...args) => {
+        debug(`[eventHandlers] Event triggered: ${key} (${type}), args: ${JSON.stringify(args)}`);
+    });
+});
+
+    // Global Macros
+    MacrosParser.registerMacro(short_memory_macro, () => get_short_memory());
+    MacrosParser.registerMacro(long_memory_macro, () => get_long_memory());
+    MacrosParser.registerMacro(combined_memory_macro, () => load_combined_summary());
+
+    // Export to the Global namespace so can be used in the console for debugging
+    window.getContext = getContext;
+    window.refresh_memory = refresh_memory;
+    window.generate_combined_summary = generate_combined_summary;
+    window.refresh_settings = refresh_settings;
+    window.update_connection_profile_dropdown = update_connection_profile_dropdown;
+
+    initializeSceneNavigatorBar();
+});
+
+export {
+    on_chat_event,
+    memoryEditInterface
 };
\ No newline at end of file
diff --git a/profileUI.js b/profileUI.js
index 543cc4c..5dd759d 100644
--- a/profileUI.js
+++ b/profileUI.js
@@ -1,321 +1,328 @@
-import {
-    get_settings,
-    set_settings,
-    get_settings_element,
-    getPresetManager,
-    check_preset_valid,
-    verify_preset,
-    get_presets,
-    get_connection_profiles,
-    verify_connection_profile,
-    check_connection_profiles_active,
-    get_current_preset,
-    get_current_connection_profile,
-    get_summary_preset_max_tokens,
-    toast,
-    toast_debounced,
-    debug,
-    error,
-    settings_content_class,
-    set_setting_ui_element,
-    settings_ui_map,
-    chat_enabled,
-    set_character_enabled_button_states,
-    get_character_profile,
-    get_chat_profile,
-    remember_button_class,
-    summarize_button_class,
-    forget_button_class,
-    css_button_separator,
-    css_message_div,
-    css_short_memory,
-    css_long_memory,
-    css_remember_memory,
-    css_exclude_memory,
-    css_lagging_memory,
-    summary_div_class,
-    summary_reasoning_class,
-    css_edit_textarea,
-    MODULE_NAME,
-    MODULE_NAME_FANCY,
-    global_settings,
-    detect_settings_difference,
-    getContext,
-    default_short_template,
-    default_long_template,
-    default_scene_template,
-    default_combined_template,
-} from './index.js';
-
-function update_save_icon_highlight() {
-    // If the current settings are different than the current profile, highlight the save button
-    if (detect_settings_difference()) {
-        $('#save_profile').addClass('button_highlight');
-    } else {
-        $('#save_profile').removeClass('button_highlight');
-    }
-}
-function update_profile_section() {
-    let context = getContext()
-
-    let current_profile = get_settings('profile')
-    let current_character_profile = get_character_profile();
-    let current_chat_profile = get_chat_profile();
-    let profile_options = Object.keys(get_settings('profiles'));
-
-    let $choose_profile_dropdown = $(`.${settings_content_class} #profile`).empty();
-    let $character = $('button#character_profile')
-    let $chat = $('button#chat_profile')
-    let $character_icon = $character.find('i')
-    let $chat_icon = $chat.find('i')
-
-
-    // Set the profile dropdowns to reflect the available profiles and the currently chosen one
-    for (let profile of profile_options) {
-        // if the current character/chat has a default profile, indicate as such
-        let text = profile
-        if (profile === current_character_profile) {
-            text = `${profile} (character)`
-        } else if (profile === current_chat_profile) {
-            text = `${profile} (chat)`
-        }
-        $choose_profile_dropdown.append(`<option value="${profile}">${text}</option>`);
-    }
-
-    // if (current_character_profile) {  // set the current chosen profile in the dropdown
-    //     choose_profile_dropdown.val(current_character_profile);
-    // }
-
-
-    // When in a group chat, the character profile lock is disabled
-    if (context.groupId) {
-        $character.prop('disabled', true)
-    }
-
-    // button highlights and icons
-
-    let lock_class = 'fa-lock'
-    let unlock_class = 'fa-unlock'
-    let highlight_class = 'button_highlight'
-
-    if (current_character_profile === current_profile) {
-        $character.addClass(highlight_class);
-        $character_icon.removeClass(unlock_class)
-        $character_icon.addClass(lock_class)
-    } else {
-        $character.removeClass(highlight_class)
-        $character_icon.removeClass(lock_class)
-        $character_icon.addClass(unlock_class)
-    }
-
-    if (current_chat_profile === current_profile) {
-        $chat.addClass(highlight_class);
-        $chat_icon.removeClass(unlock_class)
-        $chat_icon.addClass(lock_class)
-    } else {
-        $chat.removeClass(highlight_class)
-        $chat_icon.removeClass(lock_class)
-        $chat_icon.addClass(unlock_class)
-    }
-}
-
-async function update_scene_summary_preset_dropdown() {
-    let $preset_select = $('#scene_summary_completion_preset');
-    let summary_preset = get_settings('scene_summary_completion_preset');
-    let preset_options = await get_presets();
-    $preset_select.empty();
-    $preset_select.append(`<option value="">Same as Current</option>`);
-    for (let option of preset_options) {
-        $preset_select.append(`<option value="${option}">${option}</option>`);
-    }
-    $preset_select.val(summary_preset);
-    $preset_select.off('click').on('click', () => update_scene_summary_preset_dropdown());
-}
-
-async function update_preset_dropdown() {
-    // set the completion preset dropdown
-    let $preset_select = $(`.${settings_content_class} #completion_preset`);
-    let summary_preset = get_settings('completion_preset')
-    let preset_options = await get_presets()
-    $preset_select.empty();
-    $preset_select.append(`<option value="">Same as Current</option>`)
-    for (let option of preset_options) {  // construct the dropdown options
-        $preset_select.append(`<option value="${option}">${option}</option>`)
-    }
-    $preset_select.val(summary_preset)
-
-    // set a click event to refresh the preset dropdown for the currently available presets
-    $preset_select.off('click').on('click', () => update_preset_dropdown());
-
-}
-async function update_combined_summary_preset_dropdown() {
-    let $preset_select = $(`.${settings_content_class} #combined_summary_completion_preset`);
-    let summary_preset = get_settings('combined_summary_completion_preset');
-    let preset_options = await get_presets();
-    $preset_select.empty();
-    $preset_select.append(`<option value="">Same as Current</option>`);
-    for (let option of preset_options) {
-        $preset_select.append(`<option value="${option}">${option}</option>`);
-    }
-    $preset_select.val(summary_preset);
-
-    // Refresh on click
-    $preset_select.off('click').on('click', () => update_combined_summary_preset_dropdown());
-}
-async function update_connection_profile_dropdown() {
-    // set the completion preset dropdown
-    let $connection_select = $(`.${settings_content_class} #connection_profile`);
-    let summary_connection = get_settings('connection_profile')
-    let connection_options = await get_connection_profiles()
-    $connection_select.empty();
-    $connection_select.append(`<option value="">Same as Current</option>`)
-    for (let option of connection_options) {  // construct the dropdown options
-        $connection_select.append(`<option value="${option}">${option}</option>`)
-    }
-    $connection_select.val(summary_connection)
-
-    // set a click event to refresh the dropdown
-    $connection_select.off('click').on('click', () => update_connection_profile_dropdown());
-}
-
-async function update_error_detection_preset_dropdown() {
-    // Set the completion preset dropdown for error detection
-    let $regular_preset_select = $(`.${settings_content_class} #regular_summary_error_detection_preset`);
-    let $combined_preset_select = $(`.${settings_content_class} #combined_summary_error_detection_preset`);
-    let regular_preset = get_settings('regular_summary_error_detection_preset');
-    let combined_preset = get_settings('combined_summary_error_detection_preset');
-    let preset_options = await get_presets();
-    
-    // Update regular summary error detection preset dropdown
-    $regular_preset_select.empty();
-    $regular_preset_select.append(`<option value="">Same as Summary</option>`);
-    for (let option of preset_options) {
-        $regular_preset_select.append(`<option value="${option}">${option}</option>`);
-    }
-    $regular_preset_select.val(regular_preset);
-    $regular_preset_select.off('click').on('click', () => update_error_detection_preset_dropdown());
-    
-    // Update combined summary error detection preset dropdown
-    $combined_preset_select.empty();
-    $combined_preset_select.append(`<option value="">Same as Combined Summary</option>`);
-    for (let option of preset_options) {
-        $combined_preset_select.append(`<option value="${option}">${option}</option>`);
-    }
-    $combined_preset_select.val(combined_preset);
-    $combined_preset_select.off('click').on('click', () => update_error_detection_preset_dropdown());
-}
-
-function refresh_settings() {
-    // Refresh all settings UI elements according to the current settings
-    debug("Refreshing settings...")
-
-    $('#scene_summary_template').val(get_settings('scene_summary_template') || default_scene_template);
-    $('#combined_summary_template').val(get_settings('combined_summary_template') || default_combined_template);
-    $('#short_template').val(get_settings('short_template') || default_short_template);
-    $('#long_template').val(get_settings('long_template') || default_long_template);
-
-        // Error detection presets
-    update_error_detection_preset_dropdown();
-    
-    // Enable/disable error detection fields based on master toggle
-    let error_detection_enabled = get_settings('error_detection_enabled');
-    $(`.${settings_content_class} .error_detection_setting`).prop('disabled', !error_detection_enabled);
-    
-    // Enable/disable type-specific error detection settings
-    let regular_error_enabled = get_settings('regular_summary_error_detection_enabled');
-    let combined_error_enabled = get_settings('combined_summary_error_detection_enabled');
-    
-    $(`.${settings_content_class} .regular_error_detection_setting`).prop('disabled', !error_detection_enabled || !regular_error_enabled);
-    $(`.${settings_content_class} .combined_error_detection_setting`).prop('disabled', !error_detection_enabled || !combined_error_enabled);
-
-    // connection profiles
-    if (check_connection_profiles_active()) {
-        update_connection_profile_dropdown()
-        check_connection_profile_valid()
-    } else { // if connection profiles extension isn't active, hide the connection profile dropdown
-        $(`.${settings_content_class} #connection_profile`).parent().hide()
-        debug("Connection profiles extension not active. Hiding connection profile dropdown.")
-    }
-
-    // completion presets
-    update_preset_dropdown();
-    update_combined_summary_preset_dropdown();
-    update_scene_summary_preset_dropdown();
-    check_preset_valid();
-
-    // if prompt doesn't have {{message}}, insert it
-    const prompt = get_settings('prompt');
-    if (typeof prompt === "string" && !prompt.includes("{{message}}")) {
-        set_settings('prompt', prompt + "\n{{message}}")
-        debug("{{message}} macro not found in summary prompt. It has been added automatically.")
-    }
-
-    // auto_summarize_message_limit must be >= auto_summarize_batch_size (unless the limit is disabled, i.e. -1)
-    let auto_limit = get_settings('auto_summarize_message_limit')
-    let batch_size = get_settings('auto_summarize_batch_size')
-    if (auto_limit >= 0 && (auto_limit < batch_size)) {
-        set_settings('auto_summarize_message_limit', get_settings('auto_summarize_batch_size'));
-        toast("The auto-summarize message limit must be greater than or equal to the batch size.", "warning")
-    }
-
-    // update the save icon highlight
-    update_save_icon_highlight();
-
-    // update the profile section
-    update_profile_section()
-
-    // iterate through the settings map and set each element to the current setting value
-    for (let [key, [element, type]] of Object.entries(settings_ui_map)) {
-        set_setting_ui_element(key, element, type);
-    }
-
-    // enable or disable settings based on others
-    if (chat_enabled()) {
-        $(`.${settings_content_class} .settings_input`).prop('disabled', false);  // enable all settings
-
-        // when auto-summarize is disabled, related settings get disabled
-        let auto_summarize = get_settings('auto_summarize');
-        get_settings_element('auto_summarize_on_send')?.prop('disabled', !auto_summarize)
-        get_settings_element('auto_summarize_message_limit')?.prop('disabled', !auto_summarize);
-        get_settings_element('auto_summarize_batch_size')?.prop('disabled', !auto_summarize);
-        get_settings_element('auto_summarize_progress')?.prop('disabled', !auto_summarize);
-        get_settings_element('summarization_delay')?.prop('disabled', !auto_summarize);
-
-
-        // If message history is disabled, disable the relevant settings
-        let history_disabled = get_settings('include_message_history_mode') === "none";
-        get_settings_element('include_message_history')?.prop('disabled', history_disabled)
-        get_settings_element('include_user_messages_in_history')?.prop('disabled', history_disabled)
-        get_settings_element('preview_message_history')?.prop('disabled', history_disabled)
-
-        if (!history_disabled && !get_settings('prompt').includes("{{history}}")) {
-            toastr.warning("To include message history, you must use the {{history}} macro in the prompt.")
-        }
-
-        // If not excluding message, then disable the option to preserve the last user message
-        let excluding_messages = get_settings('exclude_messages_after_threshold')
-        get_settings_element('keep_last_user_message')?.prop('disabled', !excluding_messages)
-
-
-    } else {  // memory is disabled for this chat
-        $(`.${settings_content_class} .settings_input`).prop('disabled', true);  // disable all settings
-    }
-
-
-    //////////////////////
-    // Settings not in the config
-
-    // set group chat character enable button state
-    set_character_enabled_button_states()
-}
-
-export {
-    update_save_icon_highlight,
-    update_profile_section,
-    update_preset_dropdown,
-    update_combined_summary_preset_dropdown,
-    update_connection_profile_dropdown,
-    refresh_settings,
-    update_error_detection_preset_dropdown,
-    update_scene_summary_preset_dropdown
+import {
+    get_settings,
+    set_settings,
+    get_settings_element,
+    getPresetManager,
+    check_preset_valid,
+    verify_preset,
+    get_presets,
+    get_connection_profiles,
+    verify_connection_profile,
+    check_connection_profiles_active,
+    check_connection_profile_valid,
+    get_current_preset,
+    get_current_connection_profile,
+    get_summary_preset_max_tokens,
+    toast,
+    toast_debounced,
+    debug,
+    error,
+    settings_content_class,
+    set_setting_ui_element,
+    settings_ui_map,
+    chat_enabled,
+    set_character_enabled_button_states,
+    get_character_profile,
+    get_chat_profile,
+    remember_button_class,
+    summarize_button_class,
+    forget_button_class,
+    css_button_separator,
+    css_message_div,
+    css_short_memory,
+    css_long_memory,
+    css_remember_memory,
+    css_exclude_memory,
+    css_lagging_memory,
+    summary_div_class,
+    summary_reasoning_class,
+    css_edit_textarea,
+    MODULE_NAME,
+    MODULE_NAME_FANCY,
+    global_settings,
+    detect_settings_difference,
+    getContext,
+    default_short_template,
+    default_long_template,
+    default_scene_template,
+    default_combined_template,
+    reset_connection_profiles_cache,
+} from './index.js';
+
+function update_save_icon_highlight() {
+    // If the current settings are different than the current profile, highlight the save button
+    if (detect_settings_difference()) {
+        $('#save_profile').addClass('button_highlight');
+    } else {
+        $('#save_profile').removeClass('button_highlight');
+    }
+}
+function update_profile_section() {
+    let context = getContext()
+
+    let current_profile = get_settings('profile')
+    let current_character_profile = get_character_profile();
+    let current_chat_profile = get_chat_profile();
+    let profile_options = Object.keys(get_settings('profiles'));
+
+    let $choose_profile_dropdown = $(`.${settings_content_class} #profile`).empty();
+    let $character = $('button#character_profile')
+    let $chat = $('button#chat_profile')
+    let $character_icon = $character.find('i')
+    let $chat_icon = $chat.find('i')
+
+
+    // Set the profile dropdowns to reflect the available profiles and the currently chosen one
+    for (let profile of profile_options) {
+        // if the current character/chat has a default profile, indicate as such
+        let text = profile
+        if (profile === current_character_profile) {
+            text = `${profile} (character)`
+        } else if (profile === current_chat_profile) {
+            text = `${profile} (chat)`
+        }
+        $choose_profile_dropdown.append(`<option value="${profile}">${text}</option>`);
+    }
+
+    // if (current_character_profile) {  // set the current chosen profile in the dropdown
+    //     choose_profile_dropdown.val(current_character_profile);
+    // }
+
+
+    // When in a group chat, the character profile lock is disabled
+    if (context.groupId) {
+        $character.prop('disabled', true)
+    }
+
+    // button highlights and icons
+
+    let lock_class = 'fa-lock'
+    let unlock_class = 'fa-unlock'
+    let highlight_class = 'button_highlight'
+
+    if (current_character_profile === current_profile) {
+        $character.addClass(highlight_class);
+        $character_icon.removeClass(unlock_class)
+        $character_icon.addClass(lock_class)
+    } else {
+        $character.removeClass(highlight_class)
+        $character_icon.removeClass(lock_class)
+        $character_icon.addClass(unlock_class)
+    }
+
+    if (current_chat_profile === current_profile) {
+        $chat.addClass(highlight_class);
+        $chat_icon.removeClass(unlock_class)
+        $chat_icon.addClass(lock_class)
+    } else {
+        $chat.removeClass(highlight_class)
+        $chat_icon.removeClass(lock_class)
+        $chat_icon.addClass(unlock_class)
+    }
+}
+
+async function update_scene_summary_preset_dropdown() {
+    let $preset_select = $('#scene_summary_completion_preset');
+    let summary_preset = get_settings('scene_summary_completion_preset');
+    let preset_options = await get_presets();
+    $preset_select.empty();
+    $preset_select.append(`<option value="">Same as Current</option>`);
+    for (let option of preset_options) {
+        $preset_select.append(`<option value="${option}">${option}</option>`);
+    }
+    $preset_select.val(summary_preset);
+    $preset_select.off('click').on('click', () => update_scene_summary_preset_dropdown());
+}
+
+async function update_preset_dropdown() {
+    // set the completion preset dropdown
+    let $preset_select = $(`.${settings_content_class} #completion_preset`);
+    let summary_preset = get_settings('completion_preset')
+    let preset_options = await get_presets()
+    $preset_select.empty();
+    $preset_select.append(`<option value="">Same as Current</option>`)
+    for (let option of preset_options) {  // construct the dropdown options
+        $preset_select.append(`<option value="${option}">${option}</option>`)
+    }
+    $preset_select.val(summary_preset)
+
+    // set a click event to refresh the preset dropdown for the currently available presets
+    $preset_select.off('click').on('click', () => update_preset_dropdown());
+
+}
+async function update_combined_summary_preset_dropdown() {
+    let $preset_select = $(`.${settings_content_class} #combined_summary_completion_preset`);
+    let summary_preset = get_settings('combined_summary_completion_preset');
+    let preset_options = await get_presets();
+    $preset_select.empty();
+    $preset_select.append(`<option value="">Same as Current</option>`);
+    for (let option of preset_options) {
+        $preset_select.append(`<option value="${option}">${option}</option>`);
+    }
+    $preset_select.val(summary_preset);
+
+    // Refresh on click
+    $preset_select.off('click').on('click', () => update_combined_summary_preset_dropdown());
+}
+async function update_connection_profile_dropdown() {
+    // Reset the connection profiles cache to force a re-check
+    reset_connection_profiles_cache();
+    
+    // set the completion preset dropdown
+    let $connection_select = $(`.${settings_content_class} #connection_profile`);
+    let summary_connection = get_settings('connection_profile')
+    
+    let connection_options = await get_connection_profiles()
+    $connection_select.empty();
+    $connection_select.append(`<option value="">Same as Current</option>`)
+    
+    if (connection_options && Array.isArray(connection_options)) {
+        for (let option of connection_options) {  // construct the dropdown options
+            $connection_select.append(`<option value="${option}">${option}</option>`)
+        }
+    }
+    $connection_select.val(summary_connection)
+
+    // set a click event to refresh the dropdown
+    $connection_select.off('click').on('click', () => update_connection_profile_dropdown());
+}
+
+async function update_error_detection_preset_dropdown() {
+    // Set the completion preset dropdown for error detection
+    let $regular_preset_select = $(`.${settings_content_class} #regular_summary_error_detection_preset`);
+    let $combined_preset_select = $(`.${settings_content_class} #combined_summary_error_detection_preset`);
+    let regular_preset = get_settings('regular_summary_error_detection_preset');
+    let combined_preset = get_settings('combined_summary_error_detection_preset');
+    let preset_options = await get_presets();
+    
+    // Update regular summary error detection preset dropdown
+    $regular_preset_select.empty();
+    $regular_preset_select.append(`<option value="">Same as Summary</option>`);
+    for (let option of preset_options) {
+        $regular_preset_select.append(`<option value="${option}">${option}</option>`);
+    }
+    $regular_preset_select.val(regular_preset);
+    $regular_preset_select.off('click').on('click', () => update_error_detection_preset_dropdown());
+    
+    // Update combined summary error detection preset dropdown
+    $combined_preset_select.empty();
+    $combined_preset_select.append(`<option value="">Same as Combined Summary</option>`);
+    for (let option of preset_options) {
+        $combined_preset_select.append(`<option value="${option}">${option}</option>`);
+    }
+    $combined_preset_select.val(combined_preset);
+    $combined_preset_select.off('click').on('click', () => update_error_detection_preset_dropdown());
+}
+
+function refresh_settings() {
+    // Refresh all settings UI elements according to the current settings
+    debug("Refreshing settings...")
+
+    $('#scene_summary_template').val(get_settings('scene_summary_template') || default_scene_template);
+    $('#combined_summary_template').val(get_settings('combined_summary_template') || default_combined_template);
+    $('#short_template').val(get_settings('short_template') || default_short_template);
+    $('#long_template').val(get_settings('long_template') || default_long_template);
+
+        // Error detection presets
+    update_error_detection_preset_dropdown();
+    
+    // Enable/disable error detection fields based on master toggle
+    let error_detection_enabled = get_settings('error_detection_enabled');
+    $(`.${settings_content_class} .error_detection_setting`).prop('disabled', !error_detection_enabled);
+    
+    // Enable/disable type-specific error detection settings
+    let regular_error_enabled = get_settings('regular_summary_error_detection_enabled');
+    let combined_error_enabled = get_settings('combined_summary_error_detection_enabled');
+    
+    $(`.${settings_content_class} .regular_error_detection_setting`).prop('disabled', !error_detection_enabled || !regular_error_enabled);
+    $(`.${settings_content_class} .combined_error_detection_setting`).prop('disabled', !error_detection_enabled || !combined_error_enabled);
+
+    // connection profiles
+    // Always show the connection profile dropdown - let the user decide if they want to use it
+    update_connection_profile_dropdown()
+    check_connection_profile_valid()
+    // Make sure the connection profile dropdown is visible
+    $(`.${settings_content_class} #connection_profile`).parent().show()
+
+    // completion presets
+    update_preset_dropdown();
+    update_combined_summary_preset_dropdown();
+    update_scene_summary_preset_dropdown();
+    check_preset_valid();
+
+    // if prompt doesn't have {{message}}, insert it
+    const prompt = get_settings('prompt');
+    if (typeof prompt === "string" && !prompt.includes("{{message}}")) {
+        set_settings('prompt', prompt + "\n{{message}}")
+        debug("{{message}} macro not found in summary prompt. It has been added automatically.")
+    }
+
+    // auto_summarize_message_limit must be >= auto_summarize_batch_size (unless the limit is disabled, i.e. -1)
+    let auto_limit = get_settings('auto_summarize_message_limit')
+    let batch_size = get_settings('auto_summarize_batch_size')
+    if (auto_limit >= 0 && (auto_limit < batch_size)) {
+        set_settings('auto_summarize_message_limit', get_settings('auto_summarize_batch_size'));
+        toast("The auto-summarize message limit must be greater than or equal to the batch size.", "warning")
+    }
+
+    // update the save icon highlight
+    update_save_icon_highlight();
+
+    // update the profile section
+    update_profile_section()
+
+    // iterate through the settings map and set each element to the current setting value
+    for (let [key, [element, type]] of Object.entries(settings_ui_map)) {
+        set_setting_ui_element(key, element, type);
+    }
+
+    // enable or disable settings based on others
+    if (chat_enabled()) {
+        $(`.${settings_content_class} .settings_input`).prop('disabled', false);  // enable all settings
+
+        // when auto-summarize is disabled, related settings get disabled
+        let auto_summarize = get_settings('auto_summarize');
+        get_settings_element('auto_summarize_on_send')?.prop('disabled', !auto_summarize)
+        get_settings_element('auto_summarize_message_limit')?.prop('disabled', !auto_summarize);
+        get_settings_element('auto_summarize_batch_size')?.prop('disabled', !auto_summarize);
+        get_settings_element('auto_summarize_progress')?.prop('disabled', !auto_summarize);
+        get_settings_element('summarization_delay')?.prop('disabled', !auto_summarize);
+
+
+        // If message history is disabled, disable the relevant settings
+        let history_disabled = get_settings('include_message_history_mode') === "none";
+        get_settings_element('include_message_history')?.prop('disabled', history_disabled)
+        get_settings_element('include_user_messages_in_history')?.prop('disabled', history_disabled)
+        get_settings_element('preview_message_history')?.prop('disabled', history_disabled)
+
+        if (!history_disabled && !get_settings('prompt').includes("{{history}}")) {
+            toastr.warning("To include message history, you must use the {{history}} macro in the prompt.")
+        }
+
+        // If not excluding message, then disable the option to preserve the last user message
+        let excluding_messages = get_settings('exclude_messages_after_threshold')
+        get_settings_element('keep_last_user_message')?.prop('disabled', !excluding_messages)
+
+
+    } else {  // memory is disabled for this chat
+        $(`.${settings_content_class} .settings_input`).prop('disabled', true);  // disable all settings
+    }
+
+
+    //////////////////////
+    // Settings not in the config
+
+    // set group chat character enable button state
+    set_character_enabled_button_states()
+}
+
+export {
+    update_save_icon_highlight,
+    update_profile_section,
+    update_preset_dropdown,
+    update_combined_summary_preset_dropdown,
+    update_connection_profile_dropdown,
+    refresh_settings,
+    update_error_detection_preset_dropdown,
+    update_scene_summary_preset_dropdown
 };
\ No newline at end of file
