// Auto-generated macro registry
// This file is automatically generated by scripts/generate-macro-index.js
// DO NOT EDIT MANUALLY - run 'npm run generate-macros' to regenerate

// Discovered macro files: active_setting_lore, candidate_entries, candidate_registry, current_running_recap, earliest_allowed_break, entry_name, existing_content, lorebook_entry_lookup_synopsis, lorebook_entry_types, lorebook_entry_types_with_guidance, message, messages, minimum_scene_length, new_content, new_entries, new_entry, prefill, scene_messages, scene_recaps
const macroFiles = [
  "active_setting_lore",
  "candidate_entries",
  "candidate_registry",
  "current_running_recap",
  "earliest_allowed_break",
  "entry_name",
  "existing_content",
  "lorebook_entry_lookup_synopsis",
  "lorebook_entry_types",
  "lorebook_entry_types_with_guidance",
  "message",
  "messages",
  "minimum_scene_length",
  "new_content",
  "new_entries",
  "new_entry",
  "prefill",
  "scene_messages",
  "scene_recaps"
];

// Dynamic import and registration
const macroModules = await Promise.all(
  macroFiles.map(file => import(`./${file}.js`))
);

// Build MACRO_NAMES object from all modules
export const MACRO_NAMES = {};
for (const mod of macroModules) {
  const upperName = mod.name.toUpperCase().replace(/-/g, '_');
  MACRO_NAMES[upperName] = mod.name;
}

// Build macroDescriptions for documentation
export const macroDescriptions = {};
for (const mod of macroModules) {
  macroDescriptions[mod.name] = mod.description;
}

// Macros where empty string is a valid result (not an error)
const MACROS_ALLOW_EMPTY = new Set([
  'current_running_recap',  // First scene has no running recap yet
  'active_setting_lore',    // No active lore entries yet
  'prefill'                 // Prefill is optional
]);

// Validation wrapper for macro builders
function validateMacroResult(macroName, args, result) {
  const isEmpty = result === null || result === undefined || result === '';

  if (isEmpty && !MACROS_ALLOW_EMPTY.has(macroName)) {
    console.error(`[MACRO ERROR] Macro '${macroName}' returned empty result!`);
    console.error(`  Input args:`, args);
    console.error(`  Result:`, result);
    console.error(`  Stack trace:`, new Error(`Macro ${macroName} validation failed`).stack);
  }

  return result;
}

// Build macroBuilders object with validation wrappers
export const macroBuilders = {};
for (const mod of macroModules) {
  const originalBuilder = mod.build;
  macroBuilders[mod.name] = function(...args) {
    const result = originalBuilder(...args);
    return validateMacroResult(mod.name, args, result);
  };
}

// Helper to get builder by name
export function getMacroBuilder(macroName) {
  return macroBuilders[macroName];
}

// Helper to build macro value
export function buildMacroValue(macroName, ...args) {
  const builder = getMacroBuilder(macroName);
  if (!builder) {
    throw new Error(`No builder found for macro: ${macroName}`);
  }
  return builder(...args);
}

// Mapping from context field names to macro names
// This allows buildAllMacroParams to know which context field feeds which macro
const CONTEXT_TO_MACRO_MAP = {
  typeDefinitions: ['lorebook_entry_types', 'lorebook_entry_types_with_guidance'],
  activeEntries: ['active_setting_lore'],
  candidateEntries: ['candidate_entries'],
  registryListing: ['candidate_registry'],
  currentRunningRecap: ['current_running_recap'],
  sceneObjects: ['message', 'scene_messages'],
  formattedMessages: ['messages'],
  prefillText: ['prefill'],
  minimumSceneLength: ['minimum_scene_length'],
  earliestAllowedBreak: ['earliest_allowed_break'],
  existingContent: ['existing_content'],
  newContent: ['new_content'],
  entryName: ['entry_name'],
  newEntry: ['new_entry'],
  newEntries: ['new_entries'],
  sceneRecaps: ['scene_recaps'],
  synopsis: ['lorebook_entry_lookup_synopsis'],
  extractedData: ['extracted_data']
};

/**
 * Build all macro params from a context object
 * This allows operations to pass all available data and get all possible macro values
 * Macros without required data will return empty string (safe - just not substituted)
 *
 * @param {Object} context - Object containing any of: typeDefinitions, activeEntries, candidateEntries,
 *   registryListing, currentRunningRecap, sceneObjects, formattedMessages, prefillText,
 *   minimumSceneLength, earliestAllowedBreak, existingContent, newContent, entryName,
 *   newEntry, newEntries, sceneRecaps, synopsis, extractedData
 * @returns {Object} Params object with all macro values that can be built from the context
 */
export function buildAllMacroParams(context) {
  const params = {};

  for (const [contextField, macroNames] of Object.entries(CONTEXT_TO_MACRO_MAP)) {
    const value = context[contextField];
    // Skip if context doesn't have this field
    if (value === undefined) {
      continue;
    }

    for (const macroName of macroNames) {
      const builder = macroBuilders[macroName];
      if (builder) {
        // Build the macro value (validation happens inside builder)
        params[macroName] = builder(value);
      }
    }
  }

  // Handle extracted_data specially - it needs JSON.stringify
  if (context.extractedData !== undefined) {
    params.extracted_data = typeof context.extractedData === 'string'
      ? context.extractedData
      : JSON.stringify(context.extractedData, null, 2);
  }

  return params;
}

// Re-export substitute functions from promptUtils
export { substitute_params, substitute_conditionals } from '../promptUtils.js';
