# Memory Injection Flow

**Category:** Memory Injection

---

## Description

The Memory Injection Flow is the end-to-end process by which recap memories are injected into LLM prompts during normal chat operations. This system intercepts chat LLM calls, determines which memories to include based on settings, formats memories for injection, and injects them at the configured position in the prompt.

---

## Overview

Memory injection is the core mechanism that makes ST-Auto-Recap's memories available to the LLM during chat. The system uses SillyTavern's extension prompt system to inject running scene recaps into the context at a configurable position, depth, and role.

### Key Components

1. **Memory Refresh Trigger**: `refresh_memory()` updates memory state and registers injection text
2. **Memory Selection**: Determines which memories to inject based on settings
3. **Memory Formatting**: Applies templates to format memory for injection
4. **Injection Registration**: Uses `setExtensionPrompt()` to register memory with SillyTavern
5. **Position/Depth/Role Control**: Fine-grained control over injection placement

### Current Scope

As of the current implementation, the memory injection flow handles:

- **Running scene recap injection** (primary memory type)
- **Automatic injection on chat events** (chat changed, message sent, message deleted, etc.)
- **Position/depth/role configuration** for injection placement
- **Template-based formatting** for memory presentation
- **Chat-level enable/disable** control

**Note**: Individual message recaps are NOT currently injected via this flow. The system was designed for individual recap injection, but the implementation currently focuses on running scene recap injection only.

---

## How It Works

### High-Level Flow

```
Chat Event (message sent, chat loaded, etc.)
    ↓
Event Handler calls refresh_memory()
    ↓
Memory Selection & Formatting
    - Get running scene recap via get_running_recap_injection()
    - Apply template formatting
    ↓
Injection Registration
    - Call ctx.setExtensionPrompt() with memory text
    - Specify position, depth, role, scan settings
    ↓
SillyTavern Prompt Building
    - ST incorporates extension prompt into final LLM prompt
    - Memory appears at specified position/depth
    ↓
LLM receives prompt with injected memory
```

### Trigger Points

Memory injection is triggered by:

1. **Chat changed**: When user switches to a different chat
2. **Message sent**: After a message is sent to the LLM
3. **Message deleted**: When a message is removed from chat
4. **Message swiped**: When user changes to a different response variant
5. **More messages loaded**: When older messages are loaded into view
6. **Manual refresh**: Via `/recap-refresh-memory` slash command

All triggers call `refresh_memory()` or `refresh_memory_debounced()`.

---

## Configuration

### Injection Settings

| Setting | Type | Default | Description |
|---------|------|---------|-------------|
| `running_scene_recap_position` | number | 2 | Where to inject (0=Before Prompt, 1=After Prompt, 2=In Prompt) |
| `running_scene_recap_depth` | number | 2 | How deep in context to inject (0=shallowest) |
| `running_scene_recap_role` | number | 0 | Role for injection (0=System, 1=User, 2=Assistant) |
| `running_scene_recap_scan` | boolean | false | Whether to scan for world info activation |
| `running_scene_recap_template` | string | (see default) | Template for formatting injection text |

### Enable/Disable Control

Memory injection can be enabled/disabled at two levels:

1. **Global toggle**: `use_global_toggle_state` + `global_toggle_state`
2. **Per-chat toggle**: `chats_enabled[chatId]` (defaults to `default_chat_enabled`)

The `chat_enabled()` function determines if injection should occur for the current chat.

---

## Memory Types

### Running Scene Recap (Currently Implemented)

The running scene recap is a combined narrative of all scene recaps, generated by an LLM to maintain a cohesive state-focused memory. This is the primary memory type injected.

**Source**: `get_running_recap_injection()` in `runningSceneRecap.js`

**Template Variables**:
- `{{running_recap}}` - Replaced with current running recap content

**Default Template**:
```markdown
# Story Memory

The following is a cumulative memory of key scenes and developments from the roleplay so far.

{{running_recap}}
```

### Individual Message Recaps (Planned, Not Implemented)

The system was designed to support individual message recap injection, but this is NOT currently implemented. The code structure in `memoryCore.js` includes:

- `update_message_inclusion_flags()` - Marks messages for inclusion
- `check_message_exclusion()` - Filters messages based on settings
- Token limit tracking for short-term memory

However, the actual injection registration (line 331 of `memoryCore.js`) only injects scene recaps:

```javascript
// Only inject scene recaps (message recaps are NOT injected)
ctx.setExtensionPrompt(`${MODULE_NAME}_scene`, scene_injection, scene_recap_position, scene_recap_depth, scene_recap_scan, scene_recap_role);
```

---

## Related Documentation

- [Running Scene Recap Injection](../running-scene-recap-injection/overview.md)
- [Injection Position Control](../injection-position-control/overview.md)
- [Injection Depth Control](../injection-depth-control/overview.md)
- [Injection Role Control](../injection-role-control/overview.md)
- [Memory Injection Features](../README.md)
- [Main Feature Overview](../../overall-overview.md)
- [Documentation Hub](../../../README.md)

---

**Status:** Comprehensive documentation complete
