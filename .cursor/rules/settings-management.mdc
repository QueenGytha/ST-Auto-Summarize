# Settings Management Guidelines

## Settings Architecture

The extension uses a hierarchical settings system with defaults, user preferences, and profiles:

### 1. Settings Structure
```javascript
// Default settings structure
export const default_settings = {
    // Core functionality
    enabled: true,
    debug_mode: false,
    
    // Summarization settings
    summary_prompt: "Summarize this message concisely:",
    summary_max_tokens: 100,
    summary_temperature: 0.7,
    validate_summaries: false,
    validation_prompt: "Validate this summary:",
    
    // Memory settings
    short_term_limit: 10,
    long_term_limit: 50,
    short_term_context_type: "percent", // "percent" or "tokens"
    short_term_context_limit: 10,
    long_term_context_type: "percent",
    long_term_context_limit: 20,
    
    // Auto-summarization
    auto_summarize: true,
    auto_summarize_before_generation: false,
    auto_summarize_lag: 1,
    auto_summarize_batch_size: 5,
    auto_summarize_limit: 10,
    
    // Message filtering
    include_user_messages: true,
    include_system_messages: false,
    include_narrator_messages: false,
    message_length_threshold: 10,
    
    // UI settings
    show_summaries: true,
    show_progress_bar: true,
    block_chat_during_summarization: false,
    
    // Advanced settings
    summarization_delay: 1000,
    max_retries: 3,
    memory_max_age: 30 * 24 * 60 * 60 * 1000, // 30 days
    memory_min_quality: 0.5
};
```

### 2. Settings Management
```javascript
// Settings manager class
class SettingsManager {
    constructor() {
        this.settings = { ...default_settings };
        this.profiles = new Map();
        this.currentProfile = 'default';
    }
    
    // Get setting value with fallback
    get(key, defaultValue = null) {
        return this.settings[key] !== undefined ? this.settings[key] : defaultValue;
    }
    
    // Set setting value
    set(key, value) {
        const oldValue = this.settings[key];
        this.settings[key] = value;
        
        // Trigger change event
        this.onSettingChanged(key, value, oldValue);
        
        // Auto-save
        this.saveSettings();
    }
    
    // Load settings from storage
    async loadSettings() {
        try {
            const stored = localStorage.getItem('auto_summarize_settings');
            if (stored) {
                const loaded = JSON.parse(stored);
                this.settings = { ...default_settings, ...loaded };
            }
            
            // Load profiles
            await this.loadProfiles();
            
            debug("Settings loaded successfully");
        } catch (err) {
            error("Failed to load settings", err);
            // Use defaults
            this.settings = { ...default_settings };
        }
    }
    
    // Save settings to storage
    saveSettings() {
        try {
            localStorage.setItem('auto_summarize_settings', JSON.stringify(this.settings));
            debug("Settings saved successfully");
        } catch (err) {
            error("Failed to save settings", err);
        }
    }
    
    // Reset to defaults
    resetToDefaults() {
        this.settings = { ...default_settings };
        this.saveSettings();
        this.onSettingsReset();
    }
}
```

## Profile Management

### 1. Profile System
```javascript
// Profile management
class ProfileManager {
    constructor() {
        this.profiles = new Map();
        this.currentProfile = 'default';
        this.autoLoadProfiles = new Map(); // character/chat -> profile mapping
    }
    
    // Create new profile
    createProfile(name, settings = {}) {
        if (this.profiles.has(name)) {
            throw new Error(`Profile "${name}" already exists`);
        }
        
        const profile = {
            name: name,
            settings: { ...default_settings, ...settings },
            created: Date.now(),
            modified: Date.now()
        };
        
        this.profiles.set(name, profile);
        this.saveProfiles();
        
        debug("Profile created", { name, settingsCount: Object.keys(settings).length });
        return profile;
    }
    
    // Load profile
    loadProfile(name) {
        const profile = this.profiles.get(name);
        if (!profile) {
            throw new Error(`Profile "${name}" not found`);
        }
        
        // Apply profile settings
        Object.assign(this.settings, profile.settings);
        this.currentProfile = name;
        
        // Save current profile name
        localStorage.setItem('auto_summarize_current_profile', name);
        
        debug("Profile loaded", { name });
        this.onProfileLoaded(profile);
    }
    
    // Save current settings as profile
    saveAsProfile(name) {
        const profile = {
            name: name,
            settings: { ...this.settings },
            created: Date.now(),
            modified: Date.now()
        };
        
        this.profiles.set(name, profile);
        this.saveProfiles();
        
        debug("Profile saved", { name });
        return profile;
    }
    
    // Delete profile
    deleteProfile(name) {
        if (name === 'default') {
            throw new Error("Cannot delete default profile");
        }
        
        const deleted = this.profiles.delete(name);
        if (deleted) {
            this.saveProfiles();
            debug("Profile deleted", { name });
        }
        
        return deleted;
    }
    
    // Export profile
    exportProfile(name) {
        const profile = this.profiles.get(name);
        if (!profile) {
            throw new Error(`Profile "${name}" not found`);
        }
        
        return JSON.stringify(profile, null, 2);
    }
    
    // Import profile
    importProfile(profileData) {
        try {
            const profile = JSON.parse(profileData);
            
            // Validate profile structure
            if (!profile.name || !profile.settings) {
                throw new Error("Invalid profile format");
            }
            
            // Check for conflicts
            if (this.profiles.has(profile.name)) {
                throw new Error(`Profile "${profile.name}" already exists`);
            }
            
            this.profiles.set(profile.name, profile);
            this.saveProfiles();
            
            debug("Profile imported", { name: profile.name });
            return profile;
            
        } catch (err) {
            error("Failed to import profile", err);
            throw err;
        }
    }
}
```

### 2. Auto-Load Profiles
```javascript
// Auto-load profiles for characters and chats
class AutoLoadManager {
    constructor(profileManager) {
        this.profileManager = profileManager;
        this.autoLoadMap = new Map();
    }
    
    // Set auto-load profile for character/chat
    setAutoLoadProfile(identifier, profileName) {
        if (profileName && !this.profileManager.profiles.has(profileName)) {
            throw new Error(`Profile "${profileName}" not found`);
        }
        
        if (profileName) {
            this.autoLoadMap.set(identifier, profileName);
        } else {
            this.autoLoadMap.delete(identifier);
        }
        
        this.saveAutoLoadMap();
    }
    
    // Get auto-load profile for current context
    getAutoLoadProfile() {
        const ctx = getContext();
        let identifier = null;
        
        if (ctx.groupId) {
            identifier = `group_${ctx.groupId}`;
        } else if (ctx.characterId) {
            identifier = `character_${ctx.characterId}`;
        } else if (ctx.chatId) {
            identifier = `chat_${ctx.chatId}`;
        }
        
        return identifier ? this.autoLoadMap.get(identifier) : null;
    }
    
    // Auto-load profile when context changes
    onContextChanged() {
        const autoLoadProfile = this.getAutoLoadProfile();
        
        if (autoLoadProfile && autoLoadProfile !== this.profileManager.currentProfile) {
            try {
                this.profileManager.loadProfile(autoLoadProfile);
                toast(`Auto-loaded profile: ${autoLoadProfile}`, 'info');
            } catch (err) {
                error("Failed to auto-load profile", err);
            }
        }
    }
}
```

## Settings UI

### 1. Settings Panel
```javascript
// Create settings UI
function createSettingsUI() {
    const container = document.createElement('div');
    container.className = 'auto_summarize_settings_panel';
    
    container.innerHTML = `
        <div class="settings_header">
            <h3>Auto-Summarize Settings</h3>
            <div class="settings_controls">
                <button class="btn btn-primary" onclick="saveSettings()">Save</button>
                <button class="btn btn-secondary" onclick="resetSettings()">Reset</button>
            </div>
        </div>
        
        <div class="settings_content">
            <div class="settings_section">
                <h4>Core Settings</h4>
                <div class="setting_group">
                    <label>
                        <input type="checkbox" id="enabled" onchange="updateSetting('enabled', this.checked)">
                        Enable Auto-Summarize
                    </label>
                </div>
                <div class="setting_group">
                    <label>
                        <input type="checkbox" id="debug_mode" onchange="updateSetting('debug_mode', this.checked)">
                        Debug Mode
                    </label>
                </div>
            </div>
            
            <div class="settings_section">
                <h4>Summarization</h4>
                <div class="setting_group">
                    <label>Summary Prompt:</label>
                    <textarea id="summary_prompt" rows="3" onchange="updateSetting('summary_prompt', this.value)"></textarea>
                </div>
                <div class="setting_group">
                    <label>Max Tokens:</label>
                    <input type="number" id="summary_max_tokens" min="10" max="1000" onchange="updateSetting('summary_max_tokens', parseInt(this.value))">
                </div>
                <div class="setting_group">
                    <label>Temperature:</label>
                    <input type="range" id="summary_temperature" min="0" max="2" step="0.1" onchange="updateSetting('summary_temperature', parseFloat(this.value))">
                    <span id="temperature_value">0.7</span>
                </div>
            </div>
            
            <div class="settings_section">
                <h4>Memory</h4>
                <div class="setting_group">
                    <label>Short-term Limit:</label>
                    <input type="number" id="short_term_limit" min="1" max="100" onchange="updateSetting('short_term_limit', parseInt(this.value))">
                </div>
                <div class="setting_group">
                    <label>Long-term Limit:</label>
                    <input type="number" id="long_term_limit" min="1" max="500" onchange="updateSetting('long_term_limit', parseInt(this.value))">
                </div>
            </div>
        </div>
    `;
    
    return container;
}
```

### 2. Settings Validation
```javascript
// Validate settings before saving
function validateSettings(settings) {
    const errors = [];
    
    // Validate numeric ranges
    if (settings.summary_max_tokens < 10 || settings.summary_max_tokens > 1000) {
        errors.push("Summary max tokens must be between 10 and 1000");
    }
    
    if (settings.summary_temperature < 0 || settings.summary_temperature > 2) {
        errors.push("Temperature must be between 0 and 2");
    }
    
    if (settings.short_term_limit < 1 || settings.short_term_limit > 100) {
        errors.push("Short-term limit must be between 1 and 100");
    }
    
    if (settings.long_term_limit < 1 || settings.long_term_limit > 500) {
        errors.push("Long-term limit must be between 1 and 500");
    }
    
    // Validate prompt length
    if (settings.summary_prompt && settings.summary_prompt.length > 2000) {
        errors.push("Summary prompt too long (max 2000 characters)");
    }
    
    return {
        valid: errors.length === 0,
        errors: errors
    };
}

// Update setting with validation
function updateSetting(key, value) {
    const validation = validateSettings({ [key]: value });
    
    if (!validation.valid) {
        toast(`Invalid setting: ${validation.errors.join(', ')}`, 'error');
        return false;
    }
    
    set_settings(key, value);
    return true;
}
```

## Settings Persistence

### 1. Storage Management
```javascript
// Enhanced storage with versioning
class SettingsStorage {
    constructor() {
        this.storageKey = 'auto_summarize_settings';
        this.version = 1;
    }
    
    // Save settings with version
    save(settings) {
        const data = {
            version: this.version,
            timestamp: Date.now(),
            settings: settings
        };
        
        try {
            localStorage.setItem(this.storageKey, JSON.stringify(data));
            return true;
        } catch (err) {
            error("Failed to save settings", err);
            return false;
        }
    }
    
    // Load settings with migration
    load() {
        try {
            const stored = localStorage.getItem(this.storageKey);
            if (!stored) return null;
            
            const data = JSON.parse(stored);
            
            // Handle version migration
            if (data.version < this.version) {
                data.settings = this.migrateSettings(data.settings, data.version);
            }
            
            return data.settings;
            
        } catch (err) {
            error("Failed to load settings", err);
            return null;
        }
    }
    
    // Migrate settings between versions
    migrateSettings(settings, fromVersion) {
        // Add migration logic here when needed
        return settings;
    }
    
    // Export settings
    export() {
        const settings = this.load();
        return JSON.stringify(settings, null, 2);
    }
    
    // Import settings
    import(settingsData) {
        try {
            const settings = JSON.parse(settingsData);
            const validation = validateSettings(settings);
            
            if (!validation.valid) {
                throw new Error(`Invalid settings: ${validation.errors.join(', ')}`);
            }
            
            this.save(settings);
            return true;
            
        } catch (err) {
            error("Failed to import settings", err);
            return false;
        }
    }
}
```

### 2. Backup and Restore
```javascript
// Settings backup system
class SettingsBackup {
    constructor(storage) {
        this.storage = storage;
        this.backupKey = 'auto_summarize_backup';
    }
    
    // Create backup
    createBackup() {
        const settings = this.storage.load();
        if (!settings) return false;
        
        const backup = {
            timestamp: Date.now(),
            settings: settings,
            version: this.storage.version
        };
        
        try {
            localStorage.setItem(this.backupKey, JSON.stringify(backup));
            debug("Settings backup created");
            return true;
        } catch (err) {
            error("Failed to create backup", err);
            return false;
        }
    }
    
    // Restore from backup
    restoreFromBackup() {
        try {
            const backupData = localStorage.getItem(this.backupKey);
            if (!backupData) return false;
            
            const backup = JSON.parse(backupData);
            this.storage.save(backup.settings);
            
            debug("Settings restored from backup");
            return true;
            
        } catch (err) {
            error("Failed to restore from backup", err);
            return false;
        }
    }
    
    // Auto-backup before changes
    autoBackup() {
        // Create backup before major changes
        this.createBackup();
    }
}
```

## Best Practices

### 1. Settings Design
- Use descriptive setting names
- Provide sensible defaults
- Group related settings together
- Include validation for all settings

### 2. User Experience
- Provide clear setting descriptions
- Use appropriate input types
- Show setting dependencies
- Offer reset and restore options

### 3. Performance
- Debounce setting saves
- Cache frequently accessed settings
- Minimize storage operations
- Use efficient validation

### 4. Compatibility
- Version settings for migration
- Handle missing settings gracefully
- Provide fallback values
- Test with different browsers
description:
globs:
alwaysApply: false
---
