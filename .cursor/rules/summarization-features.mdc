# Summarization Features Guidelines

## Core Summarization Architecture

The extension provides multiple types of summarization with different purposes and behaviors:

### 1. Message Summarization
```javascript
// Main message summarization function
async function summarizeMessage(message, options = {}) {
    const {
        force = false,
        showProgress = true,
        validate = true
    } = options;
    
    // Check if summarization is needed
    if (!force && get_data(message, 'memory')) {
        debug("Message already summarized");
        return get_data(message, 'memory');
    }
    
    // Validate message eligibility
    if (!shouldSummarizeMessage(message)) {
        debug("Message not eligible for summarization");
        return null;
    }
    
    // Show progress if requested
    if (showProgress) {
        progress_bar.show("Summarizing message...", 1);
    }
    
    try {
        // Generate summary
        const summary = await generateSummary(message);
        
        // Validate summary if enabled
        if (validate && get_settings('validate_summaries')) {
            const validation = await validateSummary(summary, message);
            if (!validation.valid) {
                error("Summary validation failed", validation.errors);
                return null;
            }
        }
        
        // Store summary
        storeSummary(message, summary);
        
        // Update UI
        updateMessageVisuals(message);
        
        debug("Message summarized successfully", {
            messageId: message.mes_uid,
            summaryLength: summary.length
        });
        
        return summary;
        
    } catch (err) {
        error("Summarization failed", err);
        return null;
    } finally {
        if (showProgress) {
            progress_bar.hide();
        }
    }
}
```

### 2. Batch Summarization
```javascript
// Summarize multiple messages efficiently
async function summarizeMessages(messages, options = {}) {
    const {
        batchSize = 5,
        delay = 1000,
        showProgress = true
    } = options;
    
    if (!messages.length) return [];
    
    debug("Starting batch summarization", { 
        messageCount: messages.length,
        batchSize: batchSize 
    });
    
    if (showProgress) {
        progress_bar.show("Summarizing messages...", messages.length);
    }
    
    const results = [];
    const rateLimiter = new RateLimiter(10, 60000); // 10 requests per minute
    
    for (let i = 0; i < messages.length; i += batchSize) {
        const batch = messages.slice(i, i + batchSize);
        
        // Process batch
        const batchResults = await Promise.all(
            batch.map(async (message) => {
                await rateLimiter.waitForSlot();
                return await summarizeMessage(message, { 
                    showProgress: false,
                    validate: false 
                });
            })
        );
        
        results.push(...batchResults);
        
        // Update progress
        if (showProgress) {
            progress_bar.update(Math.min(i + batchSize, messages.length));
        }
        
        // Delay between batches
        if (i + batchSize < messages.length) {
            await new Promise(resolve => setTimeout(resolve, delay));
        }
    }
    
    if (showProgress) {
        progress_bar.hide();
    }
    
    debug("Batch summarization completed", {
        processed: results.filter(r => r !== null).length,
        total: messages.length
    });
    
    return results;
}
```

### 3. Combined Summary Generation
```javascript
// Generate a single narrative summary from all message summaries
async function generateCombinedSummary(messages, options = {}) {
    const {
        maxTokens = 500,
        temperature = 0.7,
        includeSceneBreaks = true
    } = options;
    
    // Collect all summaries
    const summaries = messages
        .map(msg => get_data(msg, 'memory'))
        .filter(summary => summary && summary.trim())
        .map(summary => summary.trim());
    
    if (!summaries.length) {
        debug("No summaries available for combined summary");
        return null;
    }
    
    // Include scene breaks if enabled
    if (includeSceneBreaks) {
        const sceneSummaries = messages
            .map(msg => get_data(msg, 'scene_summary_memory'))
            .filter(summary => summary && summary.trim());
        summaries.push(...sceneSummaries);
    }
    
    // Create combined summary prompt
    const prompt = formatCombinedSummaryPrompt(summaries);
    
    try {
        const result = await generateRaw({
            system: get_settings('combined_summary_prompt'),
            prompt: prompt,
            max_tokens: maxTokens,
            temperature: temperature
        });
        
        return result.content;
        
    } catch (err) {
        error("Combined summary generation failed", err);
        return null;
    }
}
```

## Summary Validation

### 1. Quality Validation
```javascript
// Validate summary quality and format
async function validateSummary(summary, originalMessage) {
    const validationPrompt = get_settings('validation_prompt');
    
    if (!validationPrompt) {
        debug("Validation disabled - no validation prompt");
        return { valid: true };
    }
    
    try {
        const result = await generateRaw({
            system: validationPrompt,
            prompt: `Summary: ${summary}\nOriginal: ${originalMessage.mes}`,
            max_tokens: 200,
            temperature: 0.1
        });
        
        return parseValidationResult(result.content);
        
    } catch (err) {
        error("Summary validation failed", err);
        return { valid: false, errors: ["Validation API error"] };
    }
}

// Parse validation result
function parseValidationResult(validationText) {
    const lines = validationText.split('\n');
    const errors = [];
    let valid = true;
    
    for (const line of lines) {
        if (line.toLowerCase().includes('error:') || line.toLowerCase().includes('invalid:')) {
            valid = false;
            errors.push(line.replace(/^(error|invalid):\s*/i, '').trim());
        }
    }
    
    return { valid, errors };
}
```

### 2. Format Validation
```javascript
// Validate summary format and structure
function validateSummaryFormat(summary) {
    const errors = [];
    
    // Check length
    const minLength = get_settings('summary_min_length') || 10;
    const maxLength = get_settings('summary_max_length') || 500;
    
    if (summary.length < minLength) {
        errors.push(`Summary too short (${summary.length} chars, minimum ${minLength})`);
    }
    
    if (summary.length > maxLength) {
        errors.push(`Summary too long (${summary.length} chars, maximum ${maxLength})`);
    }
    
    // Check for common issues
    if (summary.toLowerCase().includes('i cannot') || summary.toLowerCase().includes('i am unable')) {
        errors.push("Summary contains refusal language");
    }
    
    if (summary.trim() === originalMessage.mes.trim()) {
        errors.push("Summary is identical to original message");
    }
    
    return {
        valid: errors.length === 0,
        errors: errors
    };
}
```

## Prompt Management

### 1. Prompt Templates
```javascript
// Format prompts with dynamic content
function formatSummaryPrompt(message, context = {}) {
    const template = get_settings('summary_prompt') || defaultSummaryPrompt;
    
    return template
        .replace('{{message}}', message.mes)
        .replace('{{character}}', message.character?.name || 'Unknown')
        .replace('{{context}}', formatContext(context))
        .replace('{{max_tokens}}', get_settings('summary_max_tokens') || 100);
}

// Format context for prompt
function formatContext(context) {
    if (!context.messages || !context.messages.length) {
        return '';
    }
    
    return context.messages
        .map(msg => `${msg.character}: ${msg.content}`)
        .join('\n');
}
```

### 2. Dynamic Prompt Selection
```javascript
// Select appropriate prompt based on message type
function selectPrompt(message) {
    if (message.is_system) {
        return get_settings('system_message_prompt') || defaultSystemPrompt;
    }
    
    if (message.is_user) {
        return get_settings('user_message_prompt') || defaultUserPrompt;
    }
    
    if (message.character) {
        return get_settings('character_message_prompt') || defaultCharacterPrompt;
    }
    
    return get_settings('summary_prompt') || defaultSummaryPrompt;
}
```

## Memory Management

### 1. Memory Storage
```javascript
// Store summary in message data
function storeSummary(message, summary) {
    const memoryData = {
        text: summary,
        timestamp: Date.now(),
        version: 1,
        validated: false
    };
    
    set_data(message, 'memory', memoryData);
    
    // Update memory inclusion status
    updateMemoryInclusion(message);
}

// Update memory inclusion based on settings
function updateMemoryInclusion(message) {
    const memory = get_data(message, 'memory');
    if (!memory) return;
    
    // Check if message should be included in short-term memory
    const shortTermLimit = get_settings('short_term_limit') || 10;
    const messageIndex = getContext().chat.indexOf(message);
    const recentMessages = getContext().chat.slice(-shortTermLimit);
    
    if (recentMessages.includes(message)) {
        set_data(message, 'include', 'short');
    } else if (get_data(message, 'remember')) {
        set_data(message, 'include', 'long');
    } else {
        set_data(message, 'include', 'excluded');
    }
}
```

### 2. Memory Retrieval
```javascript
// Get short-term memory for injection
function getShortTermMemory() {
    const ctx = getContext();
    const limit = get_settings('short_term_limit') || 10;
    const recentMessages = ctx.chat.slice(-limit);
    
    const memories = recentMessages
        .map(msg => get_data(msg, 'memory'))
        .filter(memory => memory && get_data(msg, 'include') === 'short')
        .map(memory => memory.text);
    
    return memories.join('\n\n');
}

// Get long-term memory for injection
function getLongTermMemory() {
    const ctx = getContext();
    const limit = get_settings('long_term_limit') || 50;
    
    const memories = ctx.chat
        .filter(msg => get_data(msg, 'include') === 'long')
        .slice(-limit)
        .map(msg => get_data(msg, 'memory'))
        .filter(memory => memory)
        .map(memory => memory.text);
    
    return memories.join('\n\n');
}
```

## Performance Optimization

### 1. Caching
```javascript
// Cache generated summaries
const summaryCache = new Map();

function getCachedSummary(message) {
    const key = generateMessageKey(message);
    const cached = summaryCache.get(key);
    
    if (cached && Date.now() - cached.timestamp < 300000) { // 5 minutes
        return cached.summary;
    }
    
    return null;
}

function cacheSummary(message, summary) {
    const key = generateMessageKey(message);
    summaryCache.set(key, {
        summary: summary,
        timestamp: Date.now()
    });
}

function generateMessageKey(message) {
    return `${message.mes_uid}_${getStringHash(message.mes)}`;
}
```

### 2. Rate Limiting
```javascript
// Rate limiter for API calls
class SummarizationRateLimiter {
    constructor(maxRequests = 10, timeWindow = 60000) {
        this.maxRequests = maxRequests;
        this.timeWindow = timeWindow;
        this.requests = [];
    }
    
    async waitForSlot() {
        const now = Date.now();
        this.requests = this.requests.filter(time => now - time < this.timeWindow);
        
        if (this.requests.length >= this.maxRequests) {
            const oldestRequest = this.requests[0];
            const waitTime = this.timeWindow - (now - oldestRequest);
            await new Promise(resolve => setTimeout(resolve, waitTime));
        }
        
        this.requests.push(now);
    }
}
```

## Best Practices

### 1. Error Handling
- Always handle API failures gracefully
- Provide meaningful error messages
- Implement retry logic for transient failures
- Log errors with context for debugging

### 2. Performance
- Use caching for expensive operations
- Implement rate limiting for API calls
- Batch operations when possible
- Show progress indicators for long operations

### 3. Quality
- Validate summaries before storing
- Use appropriate prompts for different message types
- Implement quality checks and filters
- Provide user feedback on summary quality

### 4. User Experience
- Show clear progress indicators
- Provide options to retry failed summaries
- Allow manual summary editing
- Give users control over summarization settings
description:
globs:
alwaysApply: false
---
