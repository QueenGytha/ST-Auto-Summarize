# Testing Guidelines

Tests for LLM-related functionality should follow these guidelines to ensure consistency and reliability.

## Test File Structure

1. Place all tests in a `__tests__/` directory:
   ```
   __tests__/
   │ └── summarization.test.js
   │ └── validation.test.js
   │ └── memory.test.js
   └── ...
   ```

2. Basic test file template:
   ```javascript
   import { describe, it, expect, beforeEach, vi } from 'vitest';
   import { summarizeMessage } from '../summarization.js';

   // Mock SillyTavern dependencies
   vi.mock('../index.js', () => ({
       get_settings: vi.fn(),
       getContext: vi.fn(),
       debug: vi.fn(),
       error: vi.fn(),
       toast: vi.fn(),
       generateRaw: vi.fn(),
       count_tokens: vi.fn(),
       getMaxContextSize: vi.fn()
   }));

   describe('summarization', () => {
       beforeEach(() => {
           vi.clearAllMocks();
       });

       it('should summarize valid message', async () => {
           // Test implementation
       });
   });
   ```

## Helper Functions

1. Always create helper functions for common test data:
   ```javascript
   function createMockMessage(overrides = {}) {
       return {
           mes: "This is a test message",
           is_user: false,
           character: { name: "Test Character" },
           timestamp: Date.now(),
           ...overrides
       };
   }

   function createMockSettings(overrides = {}) {
       return {
           summary_prompt: "Summarize this message:",
           summary_max_tokens: 100,
           summary_temperature: 0.7,
           validate_summaries: false,
           ...overrides
       };
   }

   function createMockContext(overrides = {}) {
       return {
           chat: [],
           characters: {},
           characterId: null,
           chatId: "test-chat",
           ...overrides
       };
   }
   ```

## Test Cases

1. Include these standard test cases:
   - Happy path with expected input
   - Error handling and edge cases
   - Invalid input validation
   - API failure scenarios
   - Token limit handling
   - Different message types (user, character, system)

2. Example test structure:
   ```javascript
   describe('summarizeMessage', () => {
       it('should successfully summarize valid message', async () => {
           const message = createMockMessage();
           const mockResult = { content: "Test summary" };
           
           vi.mocked(generateRaw).mockResolvedValue(mockResult);
           vi.mocked(get_settings).mockImplementation(createMockSettings);
           
           const result = await summarizeMessage({ message });
           
           expect(result).toBe("Test summary");
           expect(generateRaw).toHaveBeenCalledWith(
               expect.objectContaining({
                   system: expect.any(String),
                   prompt: expect.any(String)
               })
           );
       });

       it('should handle API errors gracefully', async () => {
           const message = createMockMessage();
           
           vi.mocked(generateRaw).mockRejectedValue(new Error('API Error'));
           vi.mocked(get_settings).mockImplementation(createMockSettings);
           
           const result = await summarizeMessage({ message });
           
           expect(result).toBeNull();
           expect(error).toHaveBeenCalledWith('Summarization failed', expect.any(Error));
           expect(toast).toHaveBeenCalledWith('Summarization failed', 'error');
       });

       it('should return null for invalid message', async () => {
           const result = await summarizeMessage({ message: null });
           
           expect(result).toBeNull();
           expect(debug).toHaveBeenCalledWith('Invalid message for summarization');
       });
   });
   ```

## Mocking Guidelines

1. Mock SillyTavern dependencies:
   ```javascript
   // Mock the entire index module
   vi.mock('../index.js', () => ({
       get_settings: vi.fn(),
       getContext: vi.fn(),
       debug: vi.fn(),
       error: vi.fn(),
       toast: vi.fn(),
       generateRaw: vi.fn(),
       count_tokens: vi.fn(),
       getMaxContextSize: vi.fn(),
       get_current_preset: vi.fn(),
       get_current_connection_profile: vi.fn(),
       set_preset: vi.fn(),
       set_connection_profile: vi.fn()
   }));
   ```

2. Mock external dependencies:
   ```javascript
   // Mock fetch for API calls
   global.fetch = vi.fn();
   
   // Mock localStorage
   Object.defineProperty(window, 'localStorage', {
       value: {
           getItem: vi.fn(),
           setItem: vi.fn(),
           removeItem: vi.fn()
       }
   });
   ```

## Best Practices

1. **Test Isolation**:
   - Each test should be independent
   - Clear mocks between tests
   - Don't rely on test execution order

2. **Descriptive Names**:
   - Use descriptive test names that explain the scenario
   - Group related tests with describe blocks
   - Use consistent naming patterns

3. **Assertions**:
   - Test both positive and negative cases
   - Verify function calls with correct parameters
   - Check error handling and logging

4. **Performance**:
   - Mock expensive operations (API calls, token counting)
   - Use appropriate timeouts for async operations
   - Avoid testing implementation details

5. **Coverage**:
   - Test all code paths including error conditions
   - Test edge cases and boundary conditions
   - Focus on public API and user-facing behavior

## Running Tests

Run tests with:
```bash
npm test
npm test -- --watch  # Watch mode
npm test -- --coverage  # Coverage report
```

## Integration Tests

For integration tests that use real LLM APIs:
```javascript
describe('integration', () => {
   it('should work with real API', async () => {
       // Only run if API key is available
       if (!process.env.TEST_API_KEY) {
           console.log('Skipping integration test - no API key');
           return;
       }
       
       // Test with real API
   }, 30000); // Longer timeout for API calls
});
```
description:
globs:
alwaysApply: false
---
