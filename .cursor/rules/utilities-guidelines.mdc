# Utilities Guidelines

## Core Utility Functions

The extension provides several utility functions in `utils.js` and other utility files:

### 1. Logging Utilities
```javascript
import { log, debug, error, toast } from './index.js';

// Basic logging
log("Extension loaded");

// Debug logging (only when debug mode enabled)
debug("Processing message", { messageId: 123 });

// Error logging with toast
error("Operation failed", err);

// User notifications
toast("Success!", "success");
toast("Warning message", "warning");
toast("Error occurred", "error");
```

### 2. Token Management
```javascript
import { count_tokens, get_context_size, get_short_token_limit, get_long_token_limit } from './index.js';

// Count tokens in text
const tokenCount = count_tokens(message.mes);

// Get context size
const contextSize = get_context_size();

// Get memory limits
const shortLimit = get_short_token_limit();
const longLimit = get_long_token_limit();
```

### 3. Settings Management
```javascript
import { get_settings, set_settings, refresh_settings } from './index.js';

// Get setting value
const maxTokens = get_settings('summary_max_tokens');

// Set setting value
set_settings('summary_max_tokens', 150);

// Refresh settings from storage
await refresh_settings();
```

### 4. Context and Data Management
```javascript
import { getContext, get_data, set_data } from './index.js';

// Get SillyTavern context
const ctx = getContext();

// Get/set message data
const memory = get_data(message, 'memory');
set_data(message, 'memory', newMemory);
```

## Common Utility Patterns

### 1. Debounced Functions
```javascript
import { debounce, debounce_timeout } from './index.js';

// Debounced save function
const saveSettingsDebounced = debounce(() => {
    saveSettings();
}, debounce_timeout.relaxed);

// Debounced toast
const toastDebounced = debounce((message, type) => {
    toast(message, type);
}, 500);
```

### 2. Async Operations with Progress
```javascript
import { progress_bar, remove_progress_bar } from './index.js';

async function processWithProgress(operations) {
    progress_bar.show("Processing...", operations.length);
    
    for (let i = 0; i < operations.length; i++) {
        await operations[i]();
        progress_bar.update(i + 1);
    }
    
    remove_progress_bar();
}
```

### 3. Error Handling Wrapper
```javascript
function withErrorHandling(operation, context = {}) {
    return async (...args) => {
        try {
            return await operation(...args);
        } catch (err) {
            error(`Operation failed: ${context.operation || 'unknown'}`, {
                ...context,
                error: err.message,
                args: args.length
            });
            return null;
        }
    };
}

// Usage
const safeSummarize = withErrorHandling(summarizeMessage, { operation: 'summarization' });
```

### 4. Validation Helpers
```javascript
function validateMessage(message) {
    if (!message || !message.mes) {
        return { valid: false, error: 'Invalid message' };
    }
    
    if (message.mes.length < 10) {
        return { valid: false, error: 'Message too short' };
    }
    
    return { valid: true };
}

function validateSettings(settings) {
    const errors = [];
    
    if (settings.summary_max_tokens < 10) {
        errors.push('Max tokens too low');
    }
    
    if (settings.short_term_limit < 1) {
        errors.push('Short term limit too low');
    }
    
    return {
        valid: errors.length === 0,
        errors: errors
    };
}
```

### 5. Data Transformation
```javascript
function formatMessageForSummary(message) {
    return {
        content: message.mes,
        character: message.character?.name || 'Unknown',
        timestamp: message.timestamp,
        type: message.is_user ? 'user' : 'character'
    };
}

function formatSummaryForStorage(summary, message) {
    return {
        text: summary,
        timestamp: Date.now(),
        messageId: message.mes_uid,
        character: message.character?.name,
        version: 1
    };
}
```

## Performance Utilities

### 1. Caching
```javascript
const cache = new Map();

function withCache(key, operation, ttl = 60000) {
    const cached = cache.get(key);
    if (cached && Date.now() - cached.timestamp < ttl) {
        return cached.value;
    }
    
    const result = operation();
    cache.set(key, { value: result, timestamp: Date.now() });
    return result;
}
```

### 2. Batch Processing
```javascript
async function processBatch(items, processor, batchSize = 5) {
    const results = [];
    
    for (let i = 0; i < items.length; i += batchSize) {
        const batch = items.slice(i, i + batchSize);
        const batchResults = await Promise.all(
            batch.map(item => processor(item))
        );
        results.push(...batchResults);
        
        // Small delay between batches
        if (i + batchSize < items.length) {
            await new Promise(resolve => setTimeout(resolve, 100));
        }
    }
    
    return results;
}
```

### 3. Rate Limiting
```javascript
class RateLimiter {
    constructor(maxRequests, timeWindow) {
        this.maxRequests = maxRequests;
        this.timeWindow = timeWindow;
        this.requests = [];
    }
    
    async waitForSlot() {
        const now = Date.now();
        this.requests = this.requests.filter(time => now - time < this.timeWindow);
        
        if (this.requests.length >= this.maxRequests) {
            const oldestRequest = this.requests[0];
            const waitTime = this.timeWindow - (now - oldestRequest);
            await new Promise(resolve => setTimeout(resolve, waitTime));
        }
        
        this.requests.push(now);
    }
}

// Usage
const apiLimiter = new RateLimiter(10, 60000); // 10 requests per minute
await apiLimiter.waitForSlot();
```

## String and Text Utilities

### 1. Text Processing
```javascript
import { trimToEndSentence } from './index.js';

function truncateText(text, maxLength) {
    if (text.length <= maxLength) return text;
    return trimToEndSentence(text.substring(0, maxLength));
}

function cleanStringForTitle(text) {
    return text.replace(/["&'<>]/g, function(match) {
        switch (match) {
            case '"': return "&quot;";
            case "&": return "&amp;";
            case "'": return "&#39;";
            case "<": return "&lt;";
            case ">": return "&gt;";
        }
    });
}
```

### 2. Hash Generation
```javascript
import { getStringHash } from './index.js';

function generateMessageHash(message) {
    return getStringHash(message.mes + message.timestamp);
}
```

## DOM Utilities

### 1. Element Management
```javascript
function createElement(tag, className, textContent) {
    const element = document.createElement(tag);
    if (className) element.className = className;
    if (textContent) element.textContent = textContent;
    return element;
}

function findOrCreateElement(selector, tag, className) {
    let element = document.querySelector(selector);
    if (!element) {
        element = createElement(tag, className);
        document.body.appendChild(element);
    }
    return element;
}
```

### 2. Event Management
```javascript
function addEventListeners(element, events) {
    Object.entries(events).forEach(([event, handler]) => {
        element.addEventListener(event, handler);
    });
}

function removeEventListeners(element, events) {
    Object.entries(events).forEach(([event, handler]) => {
        element.removeEventListener(event, handler);
    });
}
```

## Best Practices

### 1. Function Design
- Keep utility functions pure when possible
- Use descriptive parameter names
- Provide default values for optional parameters
- Return consistent data structures

### 2. Error Handling
- Always handle potential errors in utility functions
- Provide meaningful error messages
- Use try-catch blocks for risky operations
- Log errors with context

### 3. Performance
- Cache expensive operations
- Use debouncing for frequent operations
- Implement rate limiting for API calls
- Batch operations when possible

### 4. Testing
- Write tests for utility functions
- Test edge cases and error conditions
- Mock external dependencies
- Use consistent test patterns
description:
globs:
alwaysApply: false
---
