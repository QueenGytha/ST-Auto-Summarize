/**
 * Checkpoint/Branch Lorebook Integration
 *
 * Creates point-in-time lorebook snapshots for checkpoints/branches.
 */

import { reconstructPointInTimeLorebook } from './lorebookReconstruction.js';
import { debug, error, toast, SUBSYSTEM, generateLorebookName, getUniqueLorebookName } from './utils.js';
import { getContext } from './index.js';
import { extension_settings } from '../../../extensions.js';
import { world_names } from '../../../world-info.js';
import { chat_metadata } from '../../../../script.js';

// Track which messages have had lorebooks created (to prevent double-creation on re-click)
const processedMessages = new Set();

/**
 * Create lorebook for checkpoint/branch at the given message
 * @param {number} messageIndex - Message index where checkpoint/branch will be created
 * @returns {Promise<string>} Lorebook name
 */
export async function createCheckpointLorebook(messageIndex) {
  // Check if already processed
  if (processedMessages.has(messageIndex)) {
    debug(SUBSYSTEM.LOREBOOK, `Lorebook already created for message ${messageIndex}, skipping`);
    return null;
  }

  const ctx = getContext();

  // Get current chat name to use as base for lorebook name
  const currentChatName = ctx.chatId || 'Unknown';

  // Generate lorebook name using template system
  const template = extension_settings?.autoLorebooks?.nameTemplate || 'z-AutoLB-{{chat}}';
  const characterName = ctx.name2 || ctx.characterName || 'Unknown';

  // Use current chat name as base (branch name will be generated by SillyTavern)
  const baseName = generateLorebookName(template, characterName, currentChatName);
  const lorebookName = getUniqueLorebookName(baseName, world_names);

  debug(SUBSYSTEM.LOREBOOK, `Creating lorebook for checkpoint/branch: ${lorebookName}`);

  toast('Creating point-in-time lorebook snapshot...', 'info');

  try {
    // Reconstruct lorebook from scene break metadata
    const result = await reconstructPointInTimeLorebook(messageIndex, lorebookName);

    debug(SUBSYSTEM.LOREBOOK,
      `âœ“ Lorebook reconstructed: ${result.lorebookName} ` +
      `(${result.entriesReconstructed} entries from message ${result.sourceMessageIndex})`
    );

    // Store lorebook name in chat metadata so it gets copied to the checkpoint/branch
    chat_metadata.world_info = result.lorebookName;

    toast(`Lorebook snapshot created: ${result.entriesReconstructed} entries`, 'success');

    // Mark as processed
    processedMessages.add(messageIndex);

    return result.lorebookName;

  } catch (err) {
    error(SUBSYSTEM.LOREBOOK, 'Lorebook reconstruction failed:', err);
    toast(`Lorebook reconstruction failed: ${err.message}`, 'error');
    throw err;
  }
}

/**
 * Dummy install function for compatibility
 */
export function installCheckpointLorebookHook() {
  // No longer needed - integration happens in buttonBindings.js
  debug(SUBSYSTEM.LOREBOOK, 'Checkpoint lorebook integration is now handled in buttonBindings.js');
}

/**
 * Uninstall the hook (for testing/cleanup)
 */
export function uninstallCheckpointLorebookHook() {
  processedMessages.clear();
  debug(SUBSYSTEM.LOREBOOK, 'Checkpoint lorebook hook uninstalled');
}
