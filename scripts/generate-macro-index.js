#!/usr/bin/env node
/* eslint-disable no-console, no-undef -- Node.js build script: console and process are required for CLI output and exit codes */

import { readdir, writeFile } from 'fs/promises';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const macrosDir = join(__dirname, '..', 'macros');
const indexPath = join(macrosDir, 'index.js');

async function generateMacroIndex() {
  // Read all files in macros directory
  const files = await readdir(macrosDir);

  // Filter to .js files, exclude index.js
  const macroFiles = files
    .filter(f => f.endsWith('.js') && f !== 'index.js')
    .map(f => f.replace('.js', ''));

  // Generate index.js content
  const content = `// Auto-generated macro registry
// This file is automatically generated by scripts/generate-macro-index.js
// DO NOT EDIT MANUALLY - run 'npm run generate-macros' to regenerate

// Discovered macro files: ${macroFiles.join(', ')}
const macroFiles = ${JSON.stringify(macroFiles, null, 2)};

// Dynamic import and registration
const macroModules = await Promise.all(
  macroFiles.map(file => import(\`./\${file}.js\`))
);

// Build MACRO_NAMES object from all modules
export const MACRO_NAMES = {};
for (const mod of macroModules) {
  const upperName = mod.name.toUpperCase().replace(/-/g, '_');
  MACRO_NAMES[upperName] = mod.name;
}

// Build macroDescriptions for documentation
export const macroDescriptions = {};
for (const mod of macroModules) {
  macroDescriptions[mod.name] = mod.description;
}

// Validation wrapper for macro builders
function validateMacroResult(macroName, args, result) {
  const isEmpty = result === null || result === undefined || result === '';

  if (isEmpty) {
    console.error(\`[MACRO ERROR] Macro '\${macroName}' returned empty result!\`);
    console.error(\`  Input args:\`, args);
    console.error(\`  Result:\`, result);
    console.error(\`  Stack trace:\`, new Error(\`Macro \${macroName} validation failed\`).stack);
  }

  return result;
}

// Build macroBuilders object with validation wrappers
export const macroBuilders = {};
for (const mod of macroModules) {
  const originalBuilder = mod.build;
  macroBuilders[mod.name] = function(...args) {
    const result = originalBuilder(...args);
    return validateMacroResult(mod.name, args, result);
  };
}

// Helper to get builder by name
export function getMacroBuilder(macroName) {
  return macroBuilders[macroName];
}

// Helper to build macro value
export function buildMacroValue(macroName, ...args) {
  const builder = getMacroBuilder(macroName);
  if (!builder) {
    throw new Error(\`No builder found for macro: \${macroName}\`);
  }
  return builder(...args);
}

// Mapping from context field names to macro names
// This allows buildAllMacroParams to know which context field feeds which macro
const CONTEXT_TO_MACRO_MAP = {
  typeDefinitions: ['lorebook_entry_types', 'lorebook_entry_types_with_guidance'],
  activeEntries: ['active_setting_lore'],
  candidateEntries: ['candidate_entries'],
  registryListing: ['candidate_registry'],
  currentRunningRecap: ['current_running_recap'],
  sceneObjects: ['message', 'scene_messages'],
  formattedMessages: ['messages'],
  prefillText: ['prefill'],
  minimumSceneLength: ['minimum_scene_length'],
  earliestAllowedBreak: ['earliest_allowed_break'],
  existingContent: ['existing_content'],
  newContent: ['new_content'],
  entryName: ['entry_name'],
  newEntry: ['new_entry'],
  newEntries: ['new_entries'],
  sceneRecaps: ['scene_recaps'],
  synopsis: ['lorebook_entry_lookup_synopsis'],
  extractedData: ['extracted_data']
};

/**
 * Build all macro params from a context object
 * This allows operations to pass all available data and get all possible macro values
 * Macros without required data will return empty string (safe - just not substituted)
 *
 * @param {Object} context - Object containing any of: typeDefinitions, activeEntries, candidateEntries,
 *   registryListing, currentRunningRecap, sceneObjects, formattedMessages, prefillText,
 *   minimumSceneLength, earliestAllowedBreak, existingContent, newContent, entryName,
 *   newEntry, newEntries, sceneRecaps, synopsis, extractedData
 * @returns {Object} Params object with all macro values that can be built from the context
 */
export function buildAllMacroParams(context) {
  const params = {};

  for (const [contextField, macroNames] of Object.entries(CONTEXT_TO_MACRO_MAP)) {
    const value = context[contextField];
    // Skip if context doesn't have this field
    if (value === undefined) {
      continue;
    }

    for (const macroName of macroNames) {
      const builder = macroBuilders[macroName];
      if (builder) {
        // Build the macro value (validation happens inside builder)
        params[macroName] = builder(value);
      }
    }
  }

  // Handle extracted_data specially - it needs JSON.stringify
  if (context.extractedData !== undefined) {
    params.extracted_data = typeof context.extractedData === 'string'
      ? context.extractedData
      : JSON.stringify(context.extractedData, null, 2);
  }

  return params;
}

// Re-export substitute functions from promptUtils
export { substitute_params, substitute_conditionals } from '../promptUtils.js';
`;

  await writeFile(indexPath, content, 'utf8');
  console.log(`âœ“ Generated macros/index.js with ${macroFiles.length} macros`);
  console.log(`  Macros: ${macroFiles.join(', ')}`);
}

generateMacroIndex().catch(err => {
  console.error('Failed to generate macro index:', err);
  process.exit(1);
});
